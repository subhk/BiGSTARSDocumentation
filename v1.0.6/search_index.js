var documenterSearchIndex = {"docs":
[{"location":"matrices/#Construction-of-differentiation-matrices","page":"Differentiation matrix","title":"Construction of differentiation matrices","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"This page documents the core spectralâ€matrix routines in BiGSTARS.jl.","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"Construction of Chebyshev differentiation matrix","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"A standard approach is followed in the construction of the differentiation matrices  \\citep{trefethen2000spectral}. The transformed Gaussâ€“Lobatto points for  z in 0 1 are given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginalign\n    z_j = frac12 cos(jpiN_z) + frac12\n    \n    j = 0 cdots N_z\nendalign","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and the first-order Chebyshev differentiation matrix is given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n  (mathrmD_z)_ij = begincases\n     dfrac2N_z^2+13   i=j=0 \n\n    dfracc_ic_j dfrac(-1)^i+jz_i-z_j\n      i neq j\n      c_i\n     begincases \n        2  i=0N_z \n        1  textotherwise\n     endcases\n\n    dfrac-cos(jpiN_z)1-cos^2(jpiN_z)\n     0  i = j  N_z\n\n    -dfrac2N_z^2+13  i=j=N_z\n  endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Chebyshev differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN = 10 # number of grid points\nz, D = cheb(N-1)\n\nnothing # hide","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"Construction of Fourier differentiation matrix","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"For y in 0L_y, the first-order Fourier differentiation matrix for even N_y is,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cotleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and for odd N_y,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cscleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"where h=2piN_y.","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Fourier differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN    = 10 # number of grid points\nmder = 1  # order of Fourier derivative\ny, D = FourierDiff(N, mder)\n\nThe domain size of `y` is 0 to 2Ï€.\nTo convert into an arbitrary domain [0, L]: \n\ny0 = L/(2Ï€) * y\nğ’Ÿ = (2Ï€/L)^1 * D\n\nFor an n-th derivative:\n\ny, D = FourierDiff(N, n)\nğ’Ÿ   = (2Ï€/L)^n * D\n\n\nnothing # hide","category":"page"},{"location":"modules/BiGSTARS/","page":"â€¦other functionsâ€¦","title":"â€¦other functionsâ€¦","text":"```@autodocs Modules = [BiGSTARS] Order = [   FourierDiff,   FourierDifffdm,   chebdif,   chebcoordtransform,   chebcoordtransformho,","category":"page"},{"location":"modules/BiGSTARS/#â€¦other-functionsâ€¦","page":"â€¦other functionsâ€¦","title":"â€¦other functionsâ€¦","text":"","category":"section"},{"location":"modules/BiGSTARS/","page":"â€¦other functionsâ€¦","title":"â€¦other functionsâ€¦","text":"]","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"# Shift and Invert Method\n\nThe **shift-and-invert** transformation is a common technique for solving the generalized eigenvalue problem\n\n```math\nA x = \\lambda B x","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"by focusing on eigenvalues near a target shift sigma:","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"(A - sigma B)^-1 B x = mu x\nquad mu = (lambda - sigma)^-1","category":"page"},{"location":"method/#Key-Advantages","page":"Methodology","title":"Key Advantages","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Selective targeting: Eigenvalues lambda closest to sigma correspond to the largest magnitudes of mu, enabling efficient extraction via Krylov solvers (e.g., Arnoldi, Lanczos).\nAccelerated convergence: Inverting the shifted operator (A - sigma B) compresses the spectrum so that desired eigenmodes dominate.","category":"page"},{"location":"method/#Algorithm-Outline","page":"Methodology","title":"Algorithm Outline","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Select a shift sigma near the eigenvalue of interest.\nFactor or set up an efficient solver for A - sigma B (e.g., LU, sparse direct, or preconditioned iterative solver).\nIterate with a Krylov-based eigensolver on (A - sigma B)^-1 B to compute mu.\nRecover the original eigenvalue:\nlambda = sigma + mu^-1","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Linear stability analysis of baroclinic instability of a 2D front based on Stone (1971)","category":"page"},{"location":"literated/Stone1971/#Governing-equations","page":"Stone1971","title":"Governing equations","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu\n\n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b\n\n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  DDt equiv partialpartial t + U (partialpartial x)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"is the material derivative, mathbfu equiv (u v epsilon w) is the velocity perturbation, epsilon=HR is the aspect ratio, p is the pressure perturbation, and b is the buoyancy perturbation. The operator","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracDDtnabla^2 w\n    + frac1epsilon^2 fracpartial zetapartial z\n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta\n\n    fracDbDt\n    + v fracpartial Bpartial y +\n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.","category":"page"},{"location":"literated/Stone1971/#Normal-mode-solutions","page":"Stone1971","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Next we consider normal-mode perturbation solutions in the form of","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew tildezeta tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. The variable sigma=sigma_r + i sigma_i. The real part represents the growth rate, and the imaginary part shows the frequency of the  perturbation.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev +\n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":" mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + (1epsilon^2)partial_z^2 - k^2big)^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"and","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":" mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"literated/Stone1971/#Boundary-conditions","page":"Stone1971","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  tildew = partial_zz tildew =\n  partial_z tildezeta = partial_z tildeb = 0\n   textat  z=0 1\nendalign","category":"page"},{"location":"literated/Stone1971/#Load-required-packages","page":"Stone1971","title":"Load required packages","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing JLD2\nusing ModelingToolkit\nusing NonlinearSolve\n\nusing BiGSTARS","category":"page"},{"location":"literated/Stone1971/#Define-the-grid-and-derivative-operators","page":"Stone1971","title":"Define the grid and derivative operators","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend\n\n\n@with_kw mutable struct Operator{N}\n    # `subperscript N' means Operator with Neumann boundary condition\n    # `subperscript D' means Operator with Dirchilet boundary condition\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÊ¸á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’ŸÊ¸Â²á¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸Â²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend\n\n@with_kw mutable struct MeanFlow{N}\n    Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n    Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡Ê¸Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Ê¸Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡Ê¸á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\nend","category":"page"},{"location":"literated/Stone1971/#Constructing-the-derivative-operators","page":"Stone1971","title":"Constructing the derivative operators","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function construct_matrices(Op, mf, grid, params)\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # basic state\n    Bâ‚€   = @. 1.0/params.Î“ * Z - Y\n    âˆ‚Ê¸Bâ‚€ = - 1.0 .* ones(size(Y))\n    âˆ‚á¶»Bâ‚€ = 1.0/params.Î“ .* ones(size(Y))\n\n    Uâ‚€      = @. 1.0 * Z - 0.5params.H\n    âˆ‚á¶»Uâ‚€    = ones( size(Y))\n    âˆ‚Ê¸Uâ‚€    = zeros(size(Y))\n\n    âˆ‚Ê¸Ê¸Uâ‚€   = zeros(size(Y))\n    âˆ‚Ê¸á¶»Uâ‚€   = zeros(size(Y))\n    âˆ‚á¶»á¶»Uâ‚€   = zeros(size(Y))\n\n      Bâ‚€  = Bâ‚€[:];\n      Uâ‚€  = Uâ‚€[:];\n    âˆ‚Ê¸Bâ‚€  = âˆ‚Ê¸Bâ‚€[:];\n    âˆ‚á¶»Bâ‚€  = âˆ‚á¶»Bâ‚€[:];\n\n    âˆ‚á¶»Uâ‚€  = âˆ‚á¶»Uâ‚€[:];\n    âˆ‚Ê¸Uâ‚€  = âˆ‚Ê¸Uâ‚€[:];\n\n    âˆ‚Ê¸Ê¸Uâ‚€ = âˆ‚Ê¸Ê¸Uâ‚€[:];\n    âˆ‚Ê¸á¶»Uâ‚€ = âˆ‚Ê¸á¶»Uâ‚€[:];\n    âˆ‚á¶»á¶»Uâ‚€ = âˆ‚á¶»á¶»Uâ‚€[:];\n\n    mf.Bâ‚€[diagind(mf.Bâ‚€)] = Bâ‚€\n    mf.Uâ‚€[diagind(mf.Uâ‚€)] = Uâ‚€\n\n    mf.âˆ‡á¶»Uâ‚€[diagind(mf.âˆ‡á¶»Uâ‚€)] = âˆ‚á¶»Uâ‚€\n    mf.âˆ‡Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Uâ‚€)] = âˆ‚Ê¸Uâ‚€\n\n    mf.âˆ‡Ê¸Bâ‚€[diagind(mf.âˆ‡Ê¸Bâ‚€)] = âˆ‚Ê¸Bâ‚€\n    mf.âˆ‡á¶»Bâ‚€[diagind(mf.âˆ‡á¶»Bâ‚€)] = âˆ‚á¶»Bâ‚€\n\n    mf.âˆ‡Ê¸Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Ê¸Uâ‚€)] = âˆ‚Ê¸Ê¸Uâ‚€;\n    mf.âˆ‡á¶»á¶»Uâ‚€[diagind(mf.âˆ‡á¶»á¶»Uâ‚€)] = âˆ‚á¶»á¶»Uâ‚€;\n    mf.âˆ‡Ê¸á¶»Uâ‚€[diagind(mf.âˆ‡Ê¸á¶»Uâ‚€)] = âˆ‚Ê¸á¶»Uâ‚€;\n\n    N  = params.Ny * params.Nz\n    Iâ° = sparse(Matrix(1.0I, N, N)) #Eye{Float64}(N)\n    sâ‚ = size(Iâ°, 1); sâ‚‚ = size(Iâ°, 2)\n\n    # allocating memory for the LHS and RHS matrices\n    ğ“›â‚ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚‚ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚ƒ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n\n    â„³â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    âˆ‡â‚•Â² = SparseMatrixCSC(Zeros(N, N))\n    H   = SparseMatrixCSC(Zeros(N, N))\n\n    âˆ‡â‚•Â² = (1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°)\n\n\n    H = inverse_Lap_hor(âˆ‡â‚•Â²)\n    @assert norm(âˆ‡â‚•Â² * H - Iâ°) â‰¤ 1.0e-4 \"difference in L2-norm should be small\"\n\n\n    Dâ´  = (1.0 * Op.ğ’Ÿâ´Ê¸\n        + 1.0/params.Îµ^4 * Op.ğ’Ÿâ´á¶»á´°\n        + 1.0params.kâ‚“^4 * Iâ°\n        - 2.0params.kâ‚“^2 * Op.ğ’ŸÂ²Ê¸\n        - 2.0/params.Îµ^2 * params.kâ‚“^2 * Op.ğ’ŸÂ²á¶»á´°\n        + 2.0/params.Îµ^2 * Op.ğ’ŸÂ²Ê¸Â²á¶»á´°)\n\n    DÂ²  = (1.0/params.Îµ^2 * Op.ğ’ŸÂ²á¶»á´° + 1.0 * âˆ‡â‚•Â²)\n    Dâ‚™Â² = (1.0/params.Îµ^2 * Op.ğ’ŸÂ²á¶»á´º + 1.0 * âˆ‡â‚•Â²)\n\n    # 1. uá¶» (vertical velocity)  equation (bcs: uá¶» = âˆ‚á¶»á¶»uá¶» = 0 @ z = 0, 1)\n    ğ“›â‚[:,    1:1sâ‚‚] = (-1.0params.E * Dâ´\n                    + 1.0im * params.kâ‚“ * mf.Uâ‚€ * DÂ²) * params.Îµ^2\n    ğ“›â‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0 * Op.ğ’Ÿá¶»á´º\n    ğ“›â‚[:,2sâ‚‚+1:3sâ‚‚] = -1.0 * âˆ‡â‚•Â²\n\n    # 2. Ï‰á¶» (vertical vorticity) equation (bcs: âˆ‚á¶»Ï‰á¶» = 0 @ z = 0, 1)\n    ğ“›â‚‚[:,    1:1sâ‚‚] = - 1.0 * mf.âˆ‡á¶»Uâ‚€ * Op.ğ’ŸÊ¸ - 1.0 * Op.ğ’Ÿá¶»á´°\n    ğ“›â‚‚[:,1sâ‚‚+1:2sâ‚‚] = (1.0im * params.kâ‚“ * mf.Uâ‚€ * Iâ°\n                    - 1.0params.E * Dâ‚™Â²)\n    ğ“›â‚‚[:,2sâ‚‚+1:3sâ‚‚] = 0.0 * Iâ°\n\n    # 3. b (buoyancy) equation (bcs: b = 0 @ z = 0, 1)\n    ğ“›â‚ƒ[:,    1:1sâ‚‚] = (1.0 * mf.âˆ‡á¶»Bâ‚€ * Iâ°\n                    - 1.0 * mf.âˆ‡Ê¸Bâ‚€ * H * Op.ğ’ŸÊ¸á¶»á´°)\n    ğ“›â‚ƒ[:,1sâ‚‚+1:2sâ‚‚] = 1.0im * params.kâ‚“ * mf.âˆ‡Ê¸Bâ‚€ * H * Iâ°\n    ğ“›â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = (-1.0params.E * Dâ‚™Â²\n                    + 1.0im * params.kâ‚“ * mf.Uâ‚€ * Iâ°)\n\n    ğ“› = ([ğ“›â‚; ğ“›â‚‚; ğ“›â‚ƒ]);\n\n\n    cnst = -1.0\n    â„³â‚[:,    1:1sâ‚‚] = 1.0cnst * params.Îµ^2 * DÂ²;\n    â„³â‚‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0cnst * Iâ°;\n    â„³â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = 1.0cnst * Iâ°;\n    â„³ = ([â„³â‚; â„³â‚‚; â„³â‚ƒ])\n\n    return ğ“›, â„³\nend","category":"page"},{"location":"literated/Stone1971/#Define-the-parameters","page":"Stone1971","title":"Define the parameters","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 1.0        # horizontal domain size\n    H::T        = 1.0        # vertical domain size\n    Î“::T        = 0.1        # front strength Î“ â‰¡ MÂ²/fÂ² = Î»/H = 1/Îµ â†’ Îµ = 1/Î“\n    Îµ::T        = 0.1        # aspect ratio Îµ â‰¡ H/L\n    kâ‚“::T       = 0.0        # x-wavenumber\n    E::T        = 1.0e-9     # Ekman number\n    Ny::Int64   = 48         # no. of y-grid points\n    Nz::Int64   = 24         # no. of z-grid points\n    method::String = \"krylov\"\nend","category":"page"},{"location":"literated/Stone1971/#Define-the-eigenvalue-solver","page":"Stone1971","title":"Define the eigenvalue solver","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    ğ“›, â„³ = construct_matrices(Op, mf, grid, params)\n\n    N = params.Ny * params.Nz\n    MatrixSize = 3N\n    @assert size(ğ“›, 1)  == MatrixSize &&\n            size(ğ“›, 2)  == MatrixSize &&\n            size(â„³, 1)  == MatrixSize &&\n            size(â„³, 2)  == MatrixSize \"matrix size does not match!\"\n\n    if params.method == \"shift_invert\"\n        Î»â‚› = EigSolver_shift_invert( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€)\n\n    elseif params.method == \"krylov\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_krylov( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n\n\n    elseif params.method == \"arnoldi\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arnoldi( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n    end\n    # ======================================================================\n    @assert length(Î»â‚›) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||ğ“›Î§ - Î»â‚›â„³Î§||â‚‚: %f \\n\" norm(ğ“› * Î§[:,1] - Î»â‚›[1] * â„³ * Î§[:,1])\n\n    @printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(Î»â‚›[1]) imag(Î»â‚›[1])\n\n    return Î»â‚›[1] #, Î§[:,1]\nend","category":"page"},{"location":"literated/Stone1971/#Solving-the-Stone-problem","page":"Stone1971","title":"Solving the Stone problem","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function solve_Stone1971(kâ‚“::Float64=0.0)\n    params      = Params{Float64}(kâ‚“=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    mf          = MeanFlow{params.Ny * params.Nz}()\n\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    Ïƒâ‚€   = 0.01\n    params.kâ‚“ = kâ‚“\n\n    Î»â‚› = EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    # Analytical solution of Stone (1971) for the growth rate\n    cnst = 1.0 + 1.0/params.Î“ + 5.0*params.Îµ^2 * params.kâ‚“^2/42.0\n    Î»â‚›â‚œ = 1.0/(2.0*âˆš3.0) * (params.kâ‚“ - 2.0/15.0 * params.kâ‚“^3 * cnst)\n\n    return abs(Î»â‚›.re - Î»â‚›â‚œ) < 1e-3\n\nend\n\nsolve_Stone1971(0.1)","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"sigma: 0.011500 \n(3456,)\nfound eigenvalue: 0.028452 + im -0.000000 \n||ğ“›Î§ - Î»â‚›â„³Î§||â‚‚: 0.000889 \nlargest growth rate : 2.8452e-02-3.3854e-10im\n","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributors'-Guide","page":"Contributor's Guide","title":"Contributors' Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"This is a short guide for potential BiGSTARS.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"Please feel free to ask us questions and chat, either by raising an issue or starting a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"We follow the ColPrac guide for collaborative practices.  New contributors should make sure to read that guide.","category":"page"},{"location":"modules/Stone1971/#Baroclinic-instability","page":"-","title":"Baroclinic instability","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu \n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b \n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"DDt equiv partialpartial t + U (partialpartial x)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"is the material derivative, mathbfu equiv (u v epsilon w) is the velocity perturbation, epsilon=HR is the aspect ratio, p is the pressure perturbation, and b is the buoyancy perturbation. The operator ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracDDtnabla^2 w \n    + frac1epsilon^2 fracpartial zetapartial z \n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta \n\n    fracDbDt\n    + v fracpartial Bpartial y + \n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.  The horizontal velocities u and v are related to the vertical velocity w and vertical vorticity zeta by the identities, ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    nabla_h^2 u = -fracpartial zetapartial y - fracpartial^2 wpartial x partial z \n\n    nabla_h^2 v = fracpartial zetapartial x - fracpartial^2 wpartial y partial z    \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"In deriving the above equations, we make use of the continuity equation and the definition of vertical vorticity zeta.","category":"page"},{"location":"modules/Stone1971/#Normal-mode","page":"-","title":"Normal mode","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Next we consider normal-mode perturbation solutions in the form of ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew  tildezeta  tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where the symbol mathfrakR denotes the real part and a variable with tilde' denotes an eigenfunction. The variable\\sigma=\\sigma_r + i \\sigma_i`. The real part represents the growth rate, and the imaginary part  shows the frequency of the  perturbation. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev + \n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 +\n(1epsilon^2)partial_z^2 - k^2big)^2  textand  mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n   \n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e., ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    tildew = partial_zz tildew = \n    partial_z tildezeta = partial_z tildeb = 0 \n     textat  z=0 1\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    mathsfitA mathsfX= sigma mathsfitB mathsfX   \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where sigma is the eigenvalue, mathsfX=tildew tildezeta tildeb^T is the eigenvector and the matrices mathsfitA, mathsfitB are the complex and real non-symmetric matrices, respectively. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"(Image: Alt text)","category":"page"},{"location":"literated/rRBC/#Finding-critical-Rayleigh-number-for-rotating-Rayleigh-Benard-Convection","page":"rRBC","title":"Finding critical Rayleigh number for rotating Rayleigh-Benard Convection","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"This code finds critical Rayleigh number for the onset of convection for rotating Rayleigh Benrad Convection (rRBC) where the domain is periodic in y-direction. The code is benchmarked against Chandrashekar's theoretical results. Hydrodynamic and hydromagnetic stability by S. Chandrasekhar, 1961 (page no-95).","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Parameter:","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Ekman number E = 10â´","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Eigenvalue: critical modified Rayleigh number Ra_c = 1897","category":"page"},{"location":"literated/rRBC/#Governing-equations","page":"rRBC","title":"Governing equations","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"In this module, we do a linear stability analysis of a 2D rotating Rayleigh-Bernard case where the domain is periodic in the y-direction, in the x-direction is of infinite extent and vertically bounded. The reason to choose this simple case is because we can find an analytical solution for this case. The background temperature profile is given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"overlinetheta = 1 - z","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The non-dimensional form of the equations governing the perturbation is given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    fracEPr fracpartial mathbfupartial t\n    + hatz times mathbfu =\n    -nabla p + Ra theta hatz + E nabla^2 mathbfu","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    fracpartial thetapartial t\n    = mathbfu cdot hatz + nabla^2 theta","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    nabla cdot mathbfu = 0","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where E=nu(fH^2) is the Ekman number and Ra = galpha Delta T(f kappa), Delta T is the temperature difference between the bottom and the top walls) is the modified Rayleigh number. By applying the operators (nabla times nabla times) and (nabla times) and taking the z-component of the equations and assuming wave-like perturbations, we obtained the equations for vertical velocity w, vertical vorticity zeta and temperature theta,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    E mathcalD^4 w - partial_z zeta = -Ra mathcalD_h^2 theta\n\n    E mathcalD^2 zeta + partial_z w = 0\n\n    mathcalD^2 b + w = 0\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The boundary conditions are:","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    w = partial_z^2 w = partial_z zeta = theta = 0\n     textat  z=01\nendalign","category":"page"},{"location":"literated/rRBC/#Normal-mode","page":"rRBC","title":"Normal mode","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Next we consider normal-mode perturbation solutions in the form of (we seek stationary solutions at the marginal state, i.e., sigma = 0),","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n w zeta theta(xyzt) = mathfrakRbig(tildew tildezeta tildetheta(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    E mathcalD^4  tildew - partial_z tildezeta = - Ra mathcalD_h^2 tildetheta\n\n    E mathcalD^2 tildezeta + partial_z tildew = 0\n\n    mathcalD^2 tildetheta + tildew = 0\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\nmathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + partial_z^2 - k^2big)^2\n textand  mathcalD_h^2 = (partial_y^2 - k^2)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n\n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"literated/rRBC/#Boundary-conditions","page":"rRBC","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    tildew = partial_zz tildew =\n    partial_z tildezeta = partial_z tildeb = 0\n     textat  z=0 1\nendalign","category":"page"},{"location":"literated/rRBC/#Generalized-eigenvalue-problem","page":"rRBC","title":"Generalized eigenvalue problem","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":" ğ“›X= Î»â„³X","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where lambda=Ra is the eigenvalue.","category":"page"},{"location":"literated/rRBC/#Load-required-packages","page":"rRBC","title":"Load required packages","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing ArnoldiMethod: partialschur, partialeigen, LR, LI, LM, SR","category":"page"},{"location":"literated/rRBC/#Let's-begin","page":"rRBC","title":"Let's begin","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"using BiGSTARS","category":"page"},{"location":"literated/rRBC/#Define-the-grid-and-derivative-operators","page":"rRBC","title":"Define the grid and derivative operators","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend\n\n\n@with_kw mutable struct Operator{N}\n    # `subperscript N' means Operator with Neumann boundary condition\n    # `subperscript D' means Operator with Dirchilet boundary condition\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÊ¸á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’ŸÊ¸Â²á¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸Â²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend\n\nfunction construct_matrices(Op, params)\n    N  = params.Ny * params.Nz\n    Iâ° = sparse(Matrix(1.0I, N, N)) #Eye{Float64}(N)\n    sâ‚ = size(Iâ°, 1); sâ‚‚ = size(Iâ°, 2)\n\n    # allocating memory for the LHS and RHS matrices\n    ğ“›â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    â„³â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    @printf \"Start constructing matrices \\n\"\n    # -------------------- construct matrix  ------------------------\n    # lhs of the matrix (size := 3 Ã— 3)\n    # eigenvectors: [uá¶» Ï‰á¶» Î¸]áµ€\n\n    âˆ‡â‚•Â² = SparseMatrixCSC(Zeros(N, N))\n    âˆ‡â‚•Â² = (1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°)\n\n    Dâ´ = (1.0 * Op.ğ’Ÿâ´Ê¸ + 1.0 * Op.ğ’Ÿâ´á¶»á´° + 2.0 * Op.ğ’ŸÂ²Ê¸Â²á¶»á´°\n        + 1.0 * params.kâ‚“^4 * Iâ°\n        - 2.0 * params.kâ‚“^2 * Op.ğ’ŸÂ²Ê¸\n        - 2.0 * params.kâ‚“^2 * Op.ğ’ŸÂ²á¶»á´°)\n\n    DÂ²  = 1.0 * Op.ğ’ŸÂ²á¶»á´° + 1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°\n    Dâ‚™Â² = 1.0 * Op.ğ’ŸÂ²á¶»á´º + 1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.kâ‚“^2 * Iâ°\n\n    # 1. uá¶» (vertical velocity) equation\n    ğ“›â‚[:,    1:1sâ‚‚] =  1.0 * params.E * Dâ´\n    ğ“›â‚[:,1sâ‚‚+1:2sâ‚‚] = -1.0 * Op.ğ’Ÿá¶»á´º\n    ğ“›â‚[:,2sâ‚‚+1:3sâ‚‚] =  0.0 * Iâ°\n\n    # 2. Ï‰á¶» (vertical vorticity) equation\n    ğ“›â‚‚[:,    1:1sâ‚‚] = 1.0 * Op.ğ’Ÿá¶»á´°\n    ğ“›â‚‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0 * params.E * Dâ‚™Â²\n    ğ“›â‚‚[:,2sâ‚‚+1:3sâ‚‚] = 0.0 * Iâ°\n\n    # 3. Î¸ (temperature) equation\n    ğ“›â‚ƒ[:,    1:1sâ‚‚] = 1.0 * Iâ°\n    ğ“›â‚ƒ[:,1sâ‚‚+1:2sâ‚‚] = 0.0 * Iâ°\n    ğ“›â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = 1.0 * DÂ²\n\n    ğ“› = ([ğ“›â‚; ğ“›â‚‚; ğ“›â‚ƒ]);\n\n\n    â„³â‚[:,2sâ‚‚+1:3sâ‚‚] = -1.0 * âˆ‡â‚•Â²\n\n    â„³ = ([â„³â‚; â„³â‚‚; â„³â‚ƒ])\n\n    return ğ“›, â„³\nend","category":"page"},{"location":"literated/rRBC/#Define-the-parameters","page":"rRBC","title":"Define the parameters","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 2Ï€          # horizontal domain size\n    H::T        = 1.0         # vertical domain size\n    Î“::T        = 0.1         # front strength Î“ â‰¡ MÂ²/fÂ² = Î»/H = 1/Îµ â†’ Îµ = 1/Î“\n    Îµ::T        = 0.1         # aspect ratio Îµ â‰¡ H/L\n    kâ‚“::T       = 0.0         # x-wavenumber\n    E::T        = 1.0e-4      # Ekman number\n    Ny::Int64   = 180         # no. of y-grid points\n    Nz::Int64   = 20          # no. of z-grid points\n    method::String   = \"arnoldi\"\nend","category":"page"},{"location":"literated/rRBC/#Define-the-eigenvalue-solver","page":"rRBC","title":"Define the eigenvalue solver","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function EigSolver(Op, params, Ïƒâ‚€)\n\n    printstyled(\"kâ‚“: $(params.kâ‚“) \\n\"; color=:blue)\n\n    ğ“›, â„³ = construct_matrices(Op,  params)\n\n    N = params.Ny * params.Nz\n    MatrixSize = 3N\n    @assert size(ğ“›, 1)  == MatrixSize &&\n            size(ğ“›, 2)  == MatrixSize &&\n            size(â„³, 1)  == MatrixSize &&\n            size(â„³, 2)  == MatrixSize \"matrix size does not match!\"\n\n    if params.method == \"shift_invert\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arpack( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LM)\n\n    elseif params.method == \"krylov\"\n\n         Î»â‚›, Î§ = EigSolver_shift_invert_krylov( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LM)\n\n    elseif params.method == \"arnoldi\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arnoldi( ğ“›, â„³,\n                                            Ïƒâ‚€=0.0,\n                                            maxiter=50000,\n                                            which=LM())\n\n        Î»â‚›, Î§ = remove_evals(Î»â‚›, Î§, 10.0, 1.0e15, \"R\")\n        Î»â‚›, Î§ = sort_evals(Î»â‚›, Î§, \"R\", \"\")\n\n    end\n\n    return Î»â‚›[1] #, Î§[:,1]\nend","category":"page"},{"location":"literated/rRBC/#solving-the-rRBC-problem","page":"rRBC","title":"solving the rRBC problem","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function solve_rRBC(kâ‚“::Float64)\n    params      = Params{Float64}(kâ‚“=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    Ïƒâ‚€   = 0.0\n    params.kâ‚“ = kâ‚“\n\n    Î»â‚› = EigSolver(Op, params, Ïƒâ‚€)\n\n    # Theoretical results from Chandrashekar (1961)\n    Î»â‚›â‚œ = 189.7\n\n    return abs(real(Î»â‚›) - Î»â‚›â‚œ)/Î»â‚›â‚œ < 1e-4\n\nend\n\nsolve_rRBC(0.0)","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"kâ‚“: 0.0 \nStart constructing matrices \nsigma: 0.000000 \nConverged: 20 of 20 eigenvalues in 171 matrix-vector products\n","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#BiGSTARS.jl-Documentation","page":"Home","title":"BiGSTARS.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BiGSTARS.jl:A Julia toolkit for bi-global linear stability analysis for geophysical flows using Chebyshev-Fourier spectral collocation method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!â€“ docs/src/literated/index.md â€“>","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples aim to demonstrate the main functionalities of each module. Have a look at our Examples collection!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stone1971 example\nrRBC example","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"You can install the latest version of BiGSTARS.jl using Juliaâ€™s built-in package manager.  Just press ] in the Julia REPL to enter package mode, then add the package and run instantiate  to build all required dependencies.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"julia> ]\n(v1.11) pkg> add BiGSTARS\n(v1.11) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"We recommend installing BiGSTARS.jl using Juliaâ€™s built-in package manager, as this installs a stable, tagged release.  Later on, you can update BiGSTARS.jl to the latest tagged version again by using the package manager:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"(v1.11) pkg> update BiGSTARS","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"Note: Some releases may introduce breaking changes to certain modules.   If something stops working or your code behaves unexpectedly after an update, feel free to open an issue.   We're more than happy to help you get your model up and running again.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"warn: Julia 1.6 or newer required; Julia 1.10 or newer strongly encouraged\nThe latest version of BiGSTARS.jl requires at least Julia v1.6 to run.   Installing BiGSTARS.jl with an older version of Julia will instead install the latest version that is compatible with your Julia installation.BiGSTARS.jl is continuously tested on Julia v1.10 (the current long-term release) and v1.11.   We strongly recommend using one of these tested Julia versions.","category":"page"}]
}
