var documenterSearchIndex = {"docs":
[{"location":"matrices/#Construction-of-differentiation-matrices","page":"Differentiation matrix","title":"Construction of differentiation matrices","text":"","category":"section"},{"location":"matrices/#This-page-documents-the-core-spectral‚Äêmatrix-routines-in-**BiGSTARS**.","page":"Differentiation matrix","title":"This page documents the core spectral‚Äêmatrix routines in BiGSTARS.","text":"","category":"section"},{"location":"matrices/#BiGSTARS.FourierDiff-Tuple{Any, Any}","page":"Differentiation matrix","title":"BiGSTARS.FourierDiff","text":"Fourier spectral differentiation.\nSpectral differentiation matrix on a grid with nfou equispaced points in [0, 2œÄ)\nINPUT\n-----\nnfou: Size of differentiation matrix.\nmder: Derivative required (non-negative integer)\nOUTPUT\n-------\nxxt: Equispaced points 0, 2pi/nfou, 4pi/nfou, ... , (nfou-1)2pi/nfou\nddm: mder'th order differentiation matrix\nExplicit formulas are used to compute the matrices for m=1 and 2.\nA discrete Fouier approach is employed for m>2. The program\ncomputes the first column and first row and then uses the\ntoeplitz command to create the matrix.\nFor mder=1 and 2 the code implements a \"flipping trick\" to\nimprove accuracy suggested by W. Don and A. Solomonoff in\nSIAM J. Sci. Comp. Vol. 6, pp. 1253--1268 (1994).\nThe flipping trick is necesary since sin t can be computed to high\nrelative precision when t is small whereas sin (pi-t) cannot.\nS.C. Reddy, J.A.C. Weideman 1998.  Corrected for MATLAB R13\nby JACW, April 2003.\n\n\n\n\n\n","category":"method"},{"location":"matrices/#BiGSTARS.FourierDiff_fdm-Tuple{Any, Int64}","page":"Differentiation matrix","title":"BiGSTARS.FourierDiff_fdm","text":"Periodic differentiation matrix constructed using finite difference method (FDM) with 2nd order accurate\n\n\n\n\n\n","category":"method"},{"location":"matrices/#BiGSTARS.cheb_coord_transform-NTuple{4, Any}","page":"Differentiation matrix","title":"BiGSTARS.cheb_coord_transform","text":"`chebcoordtransform transform' : transform the deravtive  operator from a domain of Œ∂ ‚àà [-1, 1] ‚Üí x ‚àà [0, L] via x = (1.0 + Œ∂) / 2.0 * L Input:     D¬π: First-order Chebyshev derivative in Œ∂     D¬≤: Second-order Chebyshev derivative in Œ∂     d¬π: Transformed coefficient      d¬≤: Transformed coefficient  Output:     D‚Çì : First-order Chebyshev derivative in x     D‚Çì‚Çì: Second-order Chebyshev derivative in x\n\n\n\n\n\n","category":"method"},{"location":"matrices/#BiGSTARS.cheb_coord_transform_ho-NTuple{8, Any}","page":"Differentiation matrix","title":"BiGSTARS.cheb_coord_transform_ho","text":"`chebcoordtransform_ho' : transform the deravtive  operator from a domain of Œ∂ ‚àà [-1, 1] ‚Üí x ‚àà [0, L] via x = (1.0 + Œ∂) / 2.0 * L Input:     D¬π: First-order Chebyshev derivative in Œ∂     D¬≤: Second-order Chebyshev derivative in Œ∂     D¬≥: First-order Chebyshev derivative in Œ∂     D‚Å¥: Second-order Chebyshev derivative in Œ∂     d¬π: Transformed coefficient      d¬≤: Transformed coefficient      d¬≥: Transformed coefficient      d‚Å¥: Transformed coefficient  Output:     D‚Çì‚Çì‚Çì : Third-order Chebyshev derivative in x     D‚Çì‚Çì‚Çì‚Çì: Fourth-order Chebyshev derivative in x\n\n\n\n\n\n","category":"method"},{"location":"matrices/#BiGSTARS.chebdif-Tuple{Any, Any}","page":"Differentiation matrix","title":"BiGSTARS.chebdif","text":"Calculate differentiation matrices using Chebyshev collocation. Returns the differentiation matrices D1, D2, .. Dmder corresponding to the mder-th derivative of the function f, at the ncheb Chebyshev nodes in the interval [-1,1]. Parameters ‚Äì‚Äì‚Äì‚Äì‚Äì ncheb : int, polynomial order. ncheb + 1 collocation points mder   : int       maximum order of the derivative, 0 < mder <= ncheb - 1 Returns ‚Äì‚Äì‚Äì- x  : ndarray      (ncheb + 1) x 1 array of Chebyshev points DM : ndarray      mder x ncheb x ncheb  array of differentiation matrices Notes ‚Äì‚Äì- This function returns  mder differentiation matrices corresponding to the 1st, 2nd, ... mder-th derivates on a Chebyshev grid of ncheb points. The matrices are constructed by differentiating ncheb-th order Chebyshev interpolants. The mder-th derivative of the grid function f is obtained by the matrix- vector multiplication .. math:: f^{(m)}i = D^{(m)}{ij}f_j The code implements two strategies for enhanced accuracy suggested by W. Don and S. Solomonoff : (a) the use of trigonometric  identities to avoid the computation of differences x(k)-x(j) (b) the use of the \"flipping trick\"  which is necessary since sin t can be computed to high relative precision when t is small whereas sin (pi-t) cannot. It may, in fact, be slightly better not to implement the strategies (a) and (b). Please consult [3] for details. This function is based on code by Nikola Mirkov http://code.google.com/p/another-chebpy References ‚Äì‚Äì‚Äì‚Äì‚Äì ..[1] B. Fornberg, Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 (1988): 699-706. ..[2] J. A. C. Weidemann and S. C. Reddy, A MATLAB Differentiation Matrix Suite, ACM Transactions on Mathematical Software, 26, (2000) : 465-519 ..[3] R. Baltensperger and M. R. Trummer, Spectral Differencing With A Twist, SIAM Journal on Scientific Computing 24, (2002) : 1465-1487 Examples ‚Äì‚Äì‚Äì‚Äì The derivatives of functions is obtained by multiplying the vector of function values by the differentiation matrix.\n\n\n\n\n\n","category":"method"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"math \\begin{align}     zj = \\frac{1}{2} \\cos{(j\\pi/Nz)} + \\frac{1}{2},     \\,\\,\\,\\,     j = 0, \\cdots, N_z. \\end{align}","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and the first-order Chebyshev differentiation matrix is given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"math \\begin{equation}   (\\mathrm{D}z){ij} = \\begin{cases}      \\dfrac{2Nz^2+1}{3},  \\,\\,\\,\\,\\, i=j=0,  \\\n    \\dfrac{ci}{cj} \\dfrac{(-1)^{i+j}}{zi-zj},      \\,\\,\\,\\,\\, i \\neq j,      \\,\\,\\,\\,\\, ci      \\begin{cases}          2, \\,\\,\\,\\,\\, i=0,Nz, \\\n        1, \\,\\,\\,\\,\\, \\text{otherwise},      \\end{cases} \\\n    \\dfrac{-\\cos{(j\\pi/Nz)}}{1-\\cos^2{(j\\pi/Nz)}},     \\,\\,\\,\\,\\, 0 < i = j < Nz, \\\n    -\\dfrac{2Nz^2+1}{3}, \\,\\,\\,\\,\\, i=j=Nz.   \\end{cases} \\end{equation}","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"\nTo construct the Chebyshev differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"julia using BiGSTARS","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"N = 10 # number of grid points z, D = cheb(N-1)","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"nothing # hide","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"\n### Construction of Fourier differentiation matrix\nFor $y \\in [0,L_y]$, the first-order Fourier differentiation matrix for even $N_y$ is,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"math \\begin{equation}     (\\mathrm{D}y){ij} = \\begin{cases}         0, \\,\\,\\,\\,\\, i=j,  \\\n        \\dfrac{\\pi}{L_y} (-1)^{i-j} \\cot{\\left(\\dfrac{(i-j)h}{2} \\right)}         \\,\\,\\,\\,\\, i \\neq j,     \\end{cases} \\end{equation}","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and for odd $N_y$,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"math \\begin{equation}     (\\mathrm{D}y){ij} = \\begin{cases}         0, \\,\\,\\,\\,\\, i=j,  \\\n        \\dfrac{\\pi}{L_y} (-1)^{i-j} \\csc{\\left(\\dfrac{(i-j)h}{2} \\right)}         \\,\\,\\,\\,\\, i \\neq j,     \\end{cases} \\end{equation}","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"where $h=2\\pi/N_y$.\n\nTo construct the Fourier differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"julia using BiGSTARS","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"N    = 10 # number of grid points mder = 1  # order of Fourier derivative y, D = FourierDiff(N, mder)","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"The domain size of y is 0 to 2œÄ. To convert into an arbitrary domain [0, L]: ","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"y0 = L/(2œÄ) * y ùíü = (2œÄ/L)^1 * D","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"For an n-th derivative:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"y, D = FourierDiff(N, n) ùíü   = (2œÄ/L)^n * D","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"nothing # hide ```","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"Linear stability analysis of baroclinic instability of a 2D front based on Stone (1971)","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu \n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b \n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"DDt equiv partialpartial t + U (partialpartial x)","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"is the material derivative, mathbfu equiv (u v epsilon w) is the velocity perturbation, epsilon=HR is the aspect ratio, p is the pressure perturbation, and b is the buoyancy perturbation. The operator","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracDDtnabla^2 w\n    + frac1epsilon^2 fracpartial zetapartial z\n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta\n\n    fracDbDt\n    + v fracpartial Bpartial y +\n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.","category":"page"},{"location":"literated/Stone1971/#Normal-mode-solutions","page":"-","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"Next we consider normal-mode perturbation solutions in the form of","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew  tildezeta  tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"where the symbol mathfrakR denotes the real part and a variable with tilde' denotes an eigenfunction. The variable\\sigma=\\sigma_r + i \\sigma_i`. The real part represents the growth rate, and the imaginary part shows the frequency of the  perturbation.","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev +\n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 +\n(1epsilon^2)partial_z^2 - k^2big)^2  textand  mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"beginalign\n    tildew = partial_zz tildew =\n    partial_z tildezeta = partial_z tildeb = 0\n     textat  z=0 1\nendalign","category":"page"},{"location":"literated/Stone1971/#load-required-packages","page":"-","title":"load required packages","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing JLD2\nusing ModelingToolkit\nusing NonlinearSolve\n\nusing BiGSTARS","category":"page"},{"location":"literated/Stone1971/#Define-the-grid-and-derivative-operators","page":"-","title":"Define the grid and derivative operators","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ùíü ∏::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ùíü¬≤ ∏::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ùíü‚Å¥ ∏::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ùíü·∂ª::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ùíü¬≤·∂ª::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ùíü‚Å¥·∂ª::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ùíü·∂ª·¥∫::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ùíü¬≤·∂ª·¥∫::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ùíü‚Å¥·∂ª·¥∫::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ùíü·∂ª·¥∞::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ùíü¬≤·∂ª·¥∞::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ùíü‚Å¥·∂ª·¥∞::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend","category":"page"},{"location":"literated/Stone1971/#subperscript-with-N'-means-Operator-with-Neumann-boundary-condition","page":"-","title":"`subperscript with N' means Operator with Neumann boundary condition","text":"","category":"section"},{"location":"literated/Stone1971/#after-kronker-product","page":"-","title":"after kronker product","text":"","category":"section"},{"location":"literated/Stone1971/#subperscript-with-D'-means-Operator-with-Dirchilet-boundary-condition","page":"-","title":"`subperscript with D' means Operator with Dirchilet boundary condition","text":"","category":"section"},{"location":"literated/Stone1971/#after-kronker-product-2","page":"-","title":"after kronker product","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"@with_kw mutable struct Operator{N}\n    ùíü ∏::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ùíü¬≤ ∏::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ùíü‚Å¥ ∏::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ùíü·∂ª::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ùíü¬≤·∂ª::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ùíü·∂ª·¥∫::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ùíü¬≤·∂ª·¥∫::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ùíü‚Å¥·∂ª·¥∫::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ùíü·∂ª·¥∞::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ùíü ∏·∂ª·¥∞::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ùíü¬≤·∂ª·¥∞::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ùíü‚Å¥·∂ª·¥∞::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ùíü ∏¬≤·∂ª·¥∞::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ùíü¬≤ ∏¬≤·∂ª·¥∞::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend\n\n@with_kw mutable struct MeanFlow{N}\n    B‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n    U‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  ‚àá ∏U‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  ‚àá·∂ªU‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  ‚àá ∏B‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  ‚àá·∂ªB‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  ‚àá ∏ ∏U‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  ‚àá·∂ª·∂ªU‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  ‚àá ∏·∂ªU‚ÇÄ::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\nend","category":"page"},{"location":"literated/Stone1971/#Constructing-the-derivative-operators","page":"-","title":"Constructing the derivative operators","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"function construct_matrices(Op, mf, grid, params)\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # basic state\n    B‚ÇÄ   = @. 1.0/params.Œì * Z - Y\n    ‚àÇ ∏B‚ÇÄ = - 1.0 .* ones(size(Y))\n    ‚àÇ·∂ªB‚ÇÄ = 1.0/params.Œì .* ones(size(Y))\n\n    U‚ÇÄ      = @. 1.0 * Z - 0.5params.H\n    ‚àÇ·∂ªU‚ÇÄ    = ones( size(Y))\n    ‚àÇ ∏U‚ÇÄ    = zeros(size(Y))\n\n    ‚àÇ ∏ ∏U‚ÇÄ   = zeros(size(Y))\n    ‚àÇ ∏·∂ªU‚ÇÄ   = zeros(size(Y))\n    ‚àÇ·∂ª·∂ªU‚ÇÄ   = zeros(size(Y))\n\n      B‚ÇÄ  = B‚ÇÄ[:];\n      U‚ÇÄ  = U‚ÇÄ[:];\n    ‚àÇ ∏B‚ÇÄ  = ‚àÇ ∏B‚ÇÄ[:];\n    ‚àÇ·∂ªB‚ÇÄ  = ‚àÇ·∂ªB‚ÇÄ[:];\n\n    ‚àÇ·∂ªU‚ÇÄ  = ‚àÇ·∂ªU‚ÇÄ[:];\n    ‚àÇ ∏U‚ÇÄ  = ‚àÇ ∏U‚ÇÄ[:];\n\n    ‚àÇ ∏ ∏U‚ÇÄ = ‚àÇ ∏ ∏U‚ÇÄ[:];\n    ‚àÇ ∏·∂ªU‚ÇÄ = ‚àÇ ∏·∂ªU‚ÇÄ[:];\n    ‚àÇ·∂ª·∂ªU‚ÇÄ = ‚àÇ·∂ª·∂ªU‚ÇÄ[:];\n\n    mf.B‚ÇÄ[diagind(mf.B‚ÇÄ)] = B‚ÇÄ\n    mf.U‚ÇÄ[diagind(mf.U‚ÇÄ)] = U‚ÇÄ\n\n    mf.‚àá·∂ªU‚ÇÄ[diagind(mf.‚àá·∂ªU‚ÇÄ)] = ‚àÇ·∂ªU‚ÇÄ\n    mf.‚àá ∏U‚ÇÄ[diagind(mf.‚àá ∏U‚ÇÄ)] = ‚àÇ ∏U‚ÇÄ\n\n    mf.‚àá ∏B‚ÇÄ[diagind(mf.‚àá ∏B‚ÇÄ)] = ‚àÇ ∏B‚ÇÄ\n    mf.‚àá·∂ªB‚ÇÄ[diagind(mf.‚àá·∂ªB‚ÇÄ)] = ‚àÇ·∂ªB‚ÇÄ\n\n    mf.‚àá ∏ ∏U‚ÇÄ[diagind(mf.‚àá ∏ ∏U‚ÇÄ)] = ‚àÇ ∏ ∏U‚ÇÄ;\n    mf.‚àá·∂ª·∂ªU‚ÇÄ[diagind(mf.‚àá·∂ª·∂ªU‚ÇÄ)] = ‚àÇ·∂ª·∂ªU‚ÇÄ;\n    mf.‚àá ∏·∂ªU‚ÇÄ[diagind(mf.‚àá ∏·∂ªU‚ÇÄ)] = ‚àÇ ∏·∂ªU‚ÇÄ;\n\n    N  = params.Ny * params.Nz\n    I‚Å∞ = sparse(Matrix(1.0I, N, N)) #Eye{Float64}(N)\n    s‚ÇÅ = size(I‚Å∞, 1); s‚ÇÇ = size(I‚Å∞, 2)\n\n    # allocating memory for the LHS and RHS matrices\n    ùìõ‚ÇÅ = SparseMatrixCSC(Zeros{ComplexF64}(s‚ÇÅ, 3s‚ÇÇ))\n    ùìõ‚ÇÇ = SparseMatrixCSC(Zeros{ComplexF64}(s‚ÇÅ, 3s‚ÇÇ))\n    ùìõ‚ÇÉ = SparseMatrixCSC(Zeros{ComplexF64}(s‚ÇÅ, 3s‚ÇÇ))\n\n    ‚Ñ≥‚ÇÅ = SparseMatrixCSC(Zeros{Float64}(s‚ÇÅ, 3s‚ÇÇ))\n    ‚Ñ≥‚ÇÇ = SparseMatrixCSC(Zeros{Float64}(s‚ÇÅ, 3s‚ÇÇ))\n    ‚Ñ≥‚ÇÉ = SparseMatrixCSC(Zeros{Float64}(s‚ÇÅ, 3s‚ÇÇ))\n\n    ‚àá‚Çï¬≤ = SparseMatrixCSC(Zeros(N, N))\n    H   = SparseMatrixCSC(Zeros(N, N))\n\n    ‚àá‚Çï¬≤ = (1.0 * Op.ùíü¬≤ ∏ - 1.0 * params.k‚Çì^2 * I‚Å∞)\n\n\n    H = inverse_Lap_hor(‚àá‚Çï¬≤)\n    @assert norm(‚àá‚Çï¬≤ * H - I‚Å∞) ‚â§ 1.0e-4 \"difference in L2-norm should be small\"\n\n\n    D‚Å¥  = (1.0 * Op.ùíü‚Å¥ ∏\n        + 1.0/params.Œµ^4 * Op.ùíü‚Å¥·∂ª·¥∞\n        + 1.0params.k‚Çì^4 * I‚Å∞\n        - 2.0params.k‚Çì^2 * Op.ùíü¬≤ ∏\n        - 2.0/params.Œµ^2 * params.k‚Çì^2 * Op.ùíü¬≤·∂ª·¥∞\n        + 2.0/params.Œµ^2 * Op.ùíü¬≤ ∏¬≤·∂ª·¥∞)\n\n    D¬≤  = (1.0/params.Œµ^2 * Op.ùíü¬≤·∂ª·¥∞ + 1.0 * ‚àá‚Çï¬≤)\n    D‚Çô¬≤ = (1.0/params.Œµ^2 * Op.ùíü¬≤·∂ª·¥∫ + 1.0 * ‚àá‚Çï¬≤)\n\n    # 1. u·∂ª (vertical velocity)  equation (bcs: u·∂ª = ‚àÇ·∂ª·∂ªu·∂ª = 0 @ z = 0, 1)\n    ùìõ‚ÇÅ[:,    1:1s‚ÇÇ] = (-1.0params.E * D‚Å¥\n                    + 1.0im * params.k‚Çì * mf.U‚ÇÄ * D¬≤) * params.Œµ^2\n    ùìõ‚ÇÅ[:,1s‚ÇÇ+1:2s‚ÇÇ] = 1.0 * Op.ùíü·∂ª·¥∫\n    ùìõ‚ÇÅ[:,2s‚ÇÇ+1:3s‚ÇÇ] = -1.0 * ‚àá‚Çï¬≤\n\n    # 2. œâ·∂ª (vertical vorticity) equation (bcs: ‚àÇ·∂ªœâ·∂ª = 0 @ z = 0, 1)\n    ùìõ‚ÇÇ[:,    1:1s‚ÇÇ] = - 1.0 * mf.‚àá·∂ªU‚ÇÄ * Op.ùíü ∏ - 1.0 * Op.ùíü·∂ª·¥∞\n    ùìõ‚ÇÇ[:,1s‚ÇÇ+1:2s‚ÇÇ] = (1.0im * params.k‚Çì * mf.U‚ÇÄ * I‚Å∞\n                    - 1.0params.E * D‚Çô¬≤)\n    ùìõ‚ÇÇ[:,2s‚ÇÇ+1:3s‚ÇÇ] = 0.0 * I‚Å∞\n\n    # 3. b (buoyancy) equation (bcs: b = 0 @ z = 0, 1)\n    ùìõ‚ÇÉ[:,    1:1s‚ÇÇ] = (1.0 * mf.‚àá·∂ªB‚ÇÄ * I‚Å∞\n                    - 1.0 * mf.‚àá ∏B‚ÇÄ * H * Op.ùíü ∏·∂ª·¥∞)\n    ùìõ‚ÇÉ[:,1s‚ÇÇ+1:2s‚ÇÇ] = 1.0im * params.k‚Çì * mf.‚àá ∏B‚ÇÄ * H * I‚Å∞\n    ùìõ‚ÇÉ[:,2s‚ÇÇ+1:3s‚ÇÇ] = (-1.0params.E * D‚Çô¬≤\n                    + 1.0im * params.k‚Çì * mf.U‚ÇÄ * I‚Å∞)\n\n    ùìõ = ([ùìõ‚ÇÅ; ùìõ‚ÇÇ; ùìõ‚ÇÉ]);\n\n\n    cnst = -1.0\n    ‚Ñ≥‚ÇÅ[:,    1:1s‚ÇÇ] = 1.0cnst * params.Œµ^2 * D¬≤;\n    ‚Ñ≥‚ÇÇ[:,1s‚ÇÇ+1:2s‚ÇÇ] = 1.0cnst * I‚Å∞;\n    ‚Ñ≥‚ÇÉ[:,2s‚ÇÇ+1:3s‚ÇÇ] = 1.0cnst * I‚Å∞;\n    ‚Ñ≥ = ([‚Ñ≥‚ÇÅ; ‚Ñ≥‚ÇÇ; ‚Ñ≥‚ÇÉ])\n\n    return ùìõ, ‚Ñ≥\nend","category":"page"},{"location":"literated/Stone1971/#Define-the-parameters","page":"-","title":"Define the parameters","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 1.0        # horizontal domain size\n    H::T        = 1.0        # vertical domain size\n    Œì::T        = 0.1        # front strength Œì ‚â° M¬≤/f¬≤ = Œª/H = 1/Œµ ‚Üí Œµ = 1/Œì\n    Œµ::T        = 0.1        # aspect ratio Œµ ‚â° H/L\n    k‚Çì::T       = 0.0        # x-wavenumber\n    E::T        = 1.0e-9     # Ekman number\n    Ny::Int64   = 48         # no. of y-grid points\n    Nz::Int64   = 24         # no. of z-grid points\n    method::String = \"krylov\"\nend","category":"page"},{"location":"literated/Stone1971/#Define-the-eigenvalue-solver","page":"-","title":"Define the eigenvalue solver","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"function EigSolver(Op, mf, grid, params, œÉ‚ÇÄ)\n\n    ùìõ, ‚Ñ≥ = construct_matrices(Op, mf, grid, params)\n\n    N = params.Ny * params.Nz\n    MatrixSize = 3N\n    @assert size(ùìõ, 1)  == MatrixSize &&\n            size(ùìõ, 2)  == MatrixSize &&\n            size(‚Ñ≥, 1)  == MatrixSize &&\n            size(‚Ñ≥, 2)  == MatrixSize \"matrix size does not match!\"\n\n    if params.method == \"shift_invert\"\n        Œª‚Çõ = EigSolver_shift_invert( ùìõ, ‚Ñ≥, œÉ‚ÇÄ=œÉ‚ÇÄ)\n\n    elseif params.method == \"krylov\"\n\n        Œª‚Çõ, Œß = EigSolver_shift_invert_krylov( ùìõ, ‚Ñ≥, œÉ‚ÇÄ=œÉ‚ÇÄ, maxiter=40, which=:LR)\n\n\n    elseif params.method == \"arnoldi\"\n\n        Œª‚Çõ, Œß = EigSolver_shift_invert_arnoldi( ùìõ, ‚Ñ≥, œÉ‚ÇÄ=œÉ‚ÇÄ, maxiter=40, which=:LR)\n    end\n    # ======================================================================\n    @assert length(Œª‚Çõ) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||ùìõŒß - Œª‚Çõ‚Ñ≥Œß||‚ÇÇ: %f \\n\" norm(ùìõ * Œß[:,1] - Œª‚Çõ[1] * ‚Ñ≥ * Œß[:,1])\n\n    @printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(Œª‚Çõ[1]) imag(Œª‚Çõ[1])\n\n    return Œª‚Çõ[1] #, Œß[:,1]\nend","category":"page"},{"location":"literated/Stone1971/#Solving-the-Stone-problem","page":"-","title":"Solving the Stone problem","text":"","category":"section"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"function solve_Stone1971(k‚Çì::Float64=0.0)\n    params      = Params{Float64}(k‚Çì=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    mf          = MeanFlow{params.Ny * params.Nz}()\n\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    œÉ‚ÇÄ   = 0.01\n    params.k‚Çì = k‚Çì\n\n    Œª‚Çõ = EigSolver(Op, mf, grid, params, œÉ‚ÇÄ)\n\n    # Analytical solution of Stone (1971) for the growth rate\n    cnst = 1.0 + 1.0/params.Œì + 5.0*params.Œµ^2 * params.k‚Çì^2/42.0\n    Œª‚Çõ‚Çú = 1.0/(2.0*‚àö3.0) * (params.k‚Çì - 2.0/15.0 * params.k‚Çì^3 * cnst)\n\n    return abs(Œª‚Çõ.re - Œª‚Çõ‚Çú) < 1e-3\n\nend\n\nsolve_Stone1971(0.1)","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"sigma: 0.011500 \n(3456,)\nfound eigenvalue: 0.028452 + im -0.000000 \n||ùìõŒß - Œª‚Çõ‚Ñ≥Œß||‚ÇÇ: 0.000659 \nlargest growth rate : 2.8452e-02-1.9291e-10im\n","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"","category":"page"},{"location":"literated/Stone1971/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributors'-Guide","page":"Contributor's guide","title":"Contributors' Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"This is a short guide for potential BiGSTARS.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"Please feel free to ask us questions and chat, either by raising an issue or starting a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices.  New contributors should make sure to read that guide.","category":"page"},{"location":"#BiGSTARS.jl-Documentation","page":"Home","title":"BiGSTARS.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BiGSTARS.jl is a collection of modules to provide solvers for problems in Geophysical Fluid Dynamics, on periodic domains using Fourier-based pseudospectral methods.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples aim to demonstrate the main functionalities of each module.  Have a look at our Examples collection!","category":"page"}]
}
