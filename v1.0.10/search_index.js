var documenterSearchIndex = {"docs":
[{"location":"contributing/#Contributors'-Guide","page":"Contributor's Guide","title":"Contributors' Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"This is a short guide for potential BiGSTARS.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"We welcome contributions and questions! If youâ€™d like to get involved, please donâ€™t hesitate to  open an issue to start a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"Thank you for helping improve BiGSTARS.jl!","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"You can install the latest version of BiGSTARS.jl using Juliaâ€™s built-in package manager.  Just press ] in the Julia REPL to enter package mode, then add the package and run instantiate  to build all required dependencies.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"julia> ]\n(v1.11) pkg> add BiGSTARS\n(v1.11) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"We recommend installing BiGSTARS.jl using Juliaâ€™s built-in package manager, as this installs a stable, tagged release.  Later on, you can update BiGSTARS.jl to the latest tagged version again by using the package manager:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"(v1.11) pkg> update BiGSTARS","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"Note: Some releases may introduce breaking changes to certain modules.   If something stops working or your code behaves unexpectedly after an update, feel free to open an issue.   We're more than happy to help you get your model up and running again.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"warn: Julia 1.6 or newer required; Julia 1.10 or newer strongly encouraged\nThe latest version of BiGSTARS.jl requires at least Julia v1.6 to run.   Installing BiGSTARS.jl with an older version of Julia will instead install the latest version that is compatible with your Julia installation.BiGSTARS.jl is continuously tested on Julia v1.10 (the current long-term release) and v1.11.   We strongly recommend using one of these tested Julia versions.","category":"page"},{"location":"modules/BiGSTARS/","page":"â€¦other functionsâ€¦","title":"â€¦other functionsâ€¦","text":"```@autodocs Modules = [BiGSTARS] Order = [   FourierDiff,   FourierDifffdm,   chebdif,   chebcoordtransform,   chebcoordtransformho,","category":"page"},{"location":"modules/BiGSTARS/#â€¦other-functionsâ€¦","page":"â€¦other functionsâ€¦","title":"â€¦other functionsâ€¦","text":"","category":"section"},{"location":"modules/BiGSTARS/","page":"â€¦other functionsâ€¦","title":"â€¦other functionsâ€¦","text":"]","category":"page"},{"location":"modules/Stone1971/#Baroclinic-instability","page":"-","title":"Baroclinic instability","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu \n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b \n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"DDt equiv partialpartial t + U (partialpartial x)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"is the material derivative, mathbfu equiv (u v epsilon w) is the velocity perturbation, epsilon=HR is the aspect ratio, p is the pressure perturbation, and b is the buoyancy perturbation. The operator ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracDDtnabla^2 w \n    + frac1epsilon^2 fracpartial zetapartial z \n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta \n\n    fracDbDt\n    + v fracpartial Bpartial y + \n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.  The horizontal velocities u and v are related to the vertical velocity w and vertical vorticity zeta by the identities, ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    nabla_h^2 u = -fracpartial zetapartial y - fracpartial^2 wpartial x partial z \n\n    nabla_h^2 v = fracpartial zetapartial x - fracpartial^2 wpartial y partial z    \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"In deriving the above equations, we make use of the continuity equation and the definition of vertical vorticity zeta.","category":"page"},{"location":"modules/Stone1971/#Normal-mode","page":"-","title":"Normal mode","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Next we consider normal-mode perturbation solutions in the form of ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew  tildezeta  tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where the symbol mathfrakR denotes the real part and a variable with tilde' denotes an eigenfunction. The variable\\sigma=\\sigma_r + i \\sigma_i`. The real part represents the growth rate, and the imaginary part  shows the frequency of the  perturbation. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev + \n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 +\n(1epsilon^2)partial_z^2 - k^2big)^2  textand  mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n   \n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e., ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    tildew = partial_zz tildew = \n    partial_z tildezeta = partial_z tildeb = 0 \n     textat  z=0 1\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    mathsfitA mathsfX= sigma mathsfitB mathsfX   \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where sigma is the eigenvalue, mathsfX=tildew tildezeta tildeb^T is the eigenvector and the matrices mathsfitA, mathsfitB are the complex and real non-symmetric matrices, respectively. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"(Image: Alt text)","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"Linear stability analysis of baroclinic instability of a 2D front based on Stone (1971)","category":"page"},{"location":"literated/Eady/#Introduction","page":"Eady","title":"Introduction","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"Eady (1949) showed that in a uniformly sheared, stratified layer between two rigid lids on an f-plane, two counter-propagating Rossby edge waves get phase locked and convert available potential energy into kinetic energy, producing baroclinic eddies that grow fastest at wavelengths about four deformation radii and on timescales of a few days.","category":"page"},{"location":"literated/Eady/#Basic-state","page":"Eady","title":"Basic state","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The basic state is given by","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    B(y z) = Ri z - y \n    U(y z) = z - 12\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where Ri is the Richardson number, and N^2 = Ri is the stratification.","category":"page"},{"location":"literated/Eady/#Governing-equations","page":"Eady","title":"Governing equations","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The non-dimensional form of the linearized version of the QG PV perturbation equation under the f-plane approximation can be expressed as,","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    fracpartial q^textqgpartial t + U fracpartial q^textqgpartial x + fracpartial psipartial x\n    fracpartial Q^textqgpartial y = E  nabla_h^2 q^textqg\n  textfor  0  z 1\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where q^textqg is the perturbation QG PV, and it is defined as","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    q^textqg = nabla_h^2 psi^textqg +\n    fracpartialpartial z\n    left(frac1N^2 fracpartial psi^textqgpartial zright)\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The variable psi^textqg describes the QG perturbation streamfunction with u^textqg=-partial_y psi^textqg and v^textqg=partial_x psi^textqg. The variable Q^textqg describes the QG PV of the basic state, which is defined as \\citep{pedlosky2013geophysical}","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    Q^textqg = -fracpartial Upartial y + fracpartialpartial zleft(fracBN^2 right)\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"and the cross-front gradient of Q^textqg is defined as","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    fracpartial Q^textqgpartial y = - fracpartialpartial zleft(fracpartial_z UN^2 right)\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The linearized perturbation buoyancy equation at the top and the bottom boundary is","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    fracpartial b^textqgpartial t + U fracpartial b^textqgpartial x\n      + fracpartial psi^textqgpartial x\n    fracpartial Bpartial y = 0\n     textat  z=0  textand  1\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where b^textqg=partial_z psi^textqg.","category":"page"},{"location":"literated/Eady/#Normal-mode-solutions","page":"Eady","title":"Normal-mode solutions","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"Next, we seek normal-mode solutions for psi^textqg and q^textqg in the form of","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    psi^textqg q^textqg = mathfrakRbig(widetildepsi^textqg\n  widetildeq^textqg big)(y z) e^i kx-sigma t\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where widetildepsi^textqg, widetildeq^textqg are the eigenfunctions of psi^textqg and q^textqg, respectively. In terms of streamfunction psi^textqg,","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    (sigma + i k U) - E mathscrLwidetildepsi^textqg\n  + i k partial_y Q^textqg widetildepsi^textqg = 0   textfor  0  z 1\n\n    (sigma + i k U_-)partial_z widetildepsi^textqg_-\n  + i k partial_y B_- widetildepsi^textqg_- = 0  textat  z = 0\n\n    (sigma + i k U_+)partial_z widetildepsi^textqg_+\n  + i k partial_y B_+ widetildepsi^textqg_+ = 0  textat  z = 1\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where mathscrL is a linear operator, and is defined as mathscrL equiv mathcalD_h^2 + 1N^2 partial_z^2, where mathcalD_h^2 = (partial_y^2 - k^2). The subscripts -+ denote the values of the fields at z=0 and z=1, respectively.","category":"page"},{"location":"literated/Eady/#Generalized-eigenvalue-problem","page":"Eady","title":"Generalized eigenvalue problem","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The above set of equations can be cast into a generalized eigenvalue problem","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n AX= Î»BX\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where lambda is the eigenvalue, and X is the eigenvector. The matrices A and B are given by","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    A = beginbmatrix\n        mathscrL  i k partial_y Q^textqg \n        mathcalD_z  0\n  endbmatrix\n  \n    B = beginbmatrix\n      sigma + i k U  i k partial_y B \n      sigma + i k U_-  0 \n      sigma + i k U_+  0\n    endbmatrix\nendalign","category":"page"},{"location":"literated/Eady/#Load-required-packages","page":"Eady","title":"Load required packages","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing JLD2\nusing ModelingToolkit\nusing NonlinearSolve\n\nusing BiGSTARS\n\n\n@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend\n\n@with_kw mutable struct Operator{N}\n    # `subperscript N' means Operator with Neumann boundary condition\n    # `subperscript D' means Operator with Dirchilet boundary condition\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\nend\n\n@with_kw mutable struct MeanFlow{N}\n    Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n    Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Uâ‚€::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Uâ‚€::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡á¶»Bâ‚€â»Â¹::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Bâ‚€â»Â²::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Qâ‚€::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡á¶»á¶»Bâ‚€::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend\n\n\nfunction Construct_DerivativeOperator!(diffMatrix, grid, params)\n    N = params.Ny * params.Nz\n\n    # ------------- setup differentiation matrices  -------------------\n    # Fourier in y-direction: y âˆˆ [0, L)\n    y1, diffMatrix.ğ’ŸÊ¸  = FourierDiff(params.Ny, 1)\n    _,  diffMatrix.ğ’ŸÂ²Ê¸ = FourierDiff(params.Ny, 2)\n    _,  diffMatrix.ğ’Ÿâ´Ê¸ = FourierDiff(params.Ny, 4)\n\n    # Transform the domain and derivative operators from [0, 2Ï€) â†’ [0, L)\n    grid.y         = params.L/2Ï€  * y1\n    diffMatrix.ğ’ŸÊ¸  = (2Ï€/params.L)^1 * diffMatrix.ğ’ŸÊ¸\n    diffMatrix.ğ’ŸÂ²Ê¸ = (2Ï€/params.L)^2 * diffMatrix.ğ’ŸÂ²Ê¸\n    diffMatrix.ğ’Ÿâ´Ê¸ = (2Ï€/params.L)^4 * diffMatrix.ğ’Ÿâ´Ê¸\n\n    z1, D1z = chebdif(params.Nz, 1)\n    _,  D2z = chebdif(params.Nz, 2)\n    _,  D3z = chebdif(params.Nz, 3)\n    _,  D4z = chebdif(params.Nz, 4)\n\n    # Transform the domain and derivative operators from [-1, 1] â†’ [0, H]\n    grid.z, diffMatrix.ğ’Ÿá¶», diffMatrix.ğ’ŸÂ²á¶»  = chebder_transform(z1,  D1z,\n                                                                    D2z,\n                                                                    zerotoL_transform,\n                                                                    params.H)\n    _, _, diffMatrix.ğ’Ÿâ´á¶» = chebder_transform_ho(z1, D1z,\n                                                    D2z,\n                                                    D3z,\n                                                    D4z,\n                                                    zerotoL_transform_ho,\n                                                    params.H)\n\n    return nothing\nend\n\nfunction ImplementBCs_cheb!(Op, diffMatrix, params)\n    IÊ¸ = sparse(Matrix(1.0I, params.Ny, params.Ny))\n    Iá¶» = sparse(Matrix(1.0I, params.Nz, params.Nz))\n\n    kron!( Op.ğ’ŸÊ¸   ,  diffMatrix.ğ’ŸÊ¸  ,  Iá¶» )\n    kron!( Op.ğ’ŸÂ²Ê¸  ,  diffMatrix.ğ’ŸÂ²Ê¸ ,  Iá¶» )\n\n    kron!( Op.ğ’Ÿá¶»   ,  IÊ¸ , diffMatrix.ğ’Ÿá¶»   )\n    kron!( Op.ğ’ŸÂ²á¶»  ,  IÊ¸ , diffMatrix.ğ’ŸÂ²á¶»  )\n\n    return nothing\nend\n\nfunction BasicState!(diffMatrix, mf, grid, params)\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # imposed buoyancy profile\n    Bâ‚€      = @. 1.0params.Ri * Z - Y\n    âˆ‚Ê¸Bâ‚€    = - 1.0 .* ones(size(Y))\n    âˆ‚á¶»Bâ‚€    = 1.0params.Ri .* ones(size(Y))\n    âˆ‚á¶»á¶»Bâ‚€   = zeros(size(Y))\n\n    âˆ‚á¶»Bâ‚€â»Â¹  = @. 1.0/âˆ‚á¶»Bâ‚€\n    âˆ‚á¶»Bâ‚€â»Â²  = @. 1.0/(âˆ‚á¶»Bâ‚€ * âˆ‚á¶»Bâ‚€)\n\n    # along-front profile\n    Uâ‚€      = @. 1.0 * Z - 0.5\n    âˆ‚á¶»Uâ‚€    = ones(size(Y))\n    âˆ‚Ê¸Uâ‚€    = zeros(size(Y))\n\n    # y-gradient of the QG PV\n    âˆ‚Ê¸Qâ‚€    = zeros(size(Y))\n\n      Bâ‚€  = Bâ‚€[:]\n      Uâ‚€  = Uâ‚€[:]\n    âˆ‚Ê¸Bâ‚€  = âˆ‚Ê¸Bâ‚€[:]\n    âˆ‚á¶»Bâ‚€  = âˆ‚á¶»Bâ‚€[:]\n    âˆ‚á¶»Uâ‚€  = âˆ‚á¶»Uâ‚€[:]\n    âˆ‚Ê¸Uâ‚€  = âˆ‚Ê¸Uâ‚€[:]\n\n    âˆ‚Ê¸Qâ‚€  = âˆ‚Ê¸Qâ‚€[:]\n\n    âˆ‚á¶»á¶»Bâ‚€ = âˆ‚á¶»á¶»Bâ‚€[:]\n\n    âˆ‚á¶»Bâ‚€â»Â¹ = âˆ‚á¶»Bâ‚€â»Â¹[:]\n    âˆ‚á¶»Bâ‚€â»Â² = âˆ‚á¶»Bâ‚€â»Â²[:]\n\n    mf.Bâ‚€[diagind(mf.Bâ‚€)] = Bâ‚€\n    mf.Uâ‚€[diagind(mf.Uâ‚€)] = Uâ‚€\n\n    mf.âˆ‡Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Uâ‚€)]   = âˆ‚Ê¸Uâ‚€\n    mf.âˆ‡á¶»Uâ‚€[diagind(mf.âˆ‡á¶»Uâ‚€)]   = âˆ‚á¶»Uâ‚€\n\n    mf.âˆ‡Ê¸Qâ‚€[diagind(mf.âˆ‡Ê¸Qâ‚€)]   = âˆ‚Ê¸Qâ‚€\n\n    mf.âˆ‡á¶»Bâ‚€â»Â¹[diagind(mf.âˆ‡á¶»Bâ‚€â»Â¹)] = âˆ‚á¶»Bâ‚€â»Â¹\n    mf.âˆ‡á¶»Bâ‚€â»Â²[diagind(mf.âˆ‡á¶»Bâ‚€â»Â²)] = âˆ‚á¶»Bâ‚€â»Â²\n\n    mf.âˆ‡á¶»á¶»Bâ‚€[diagind(mf.âˆ‡á¶»á¶»Bâ‚€)] = âˆ‚á¶»á¶»Bâ‚€\n\n    return nothing\nend\n\nfunction construct_matrices(Op, mf, params)\n    N  = params.Ny * params.Nz\n    Iâ° = sparse(Matrix(1.0I, N, N))\n    sâ‚ = size(Iâ°, 1); sâ‚‚ = size(Iâ°, 2)\n\n    # allocating memory for the LHS and RHS matrices\n    ğ“› = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, sâ‚‚))\n    â„³ = SparseMatrixCSC(Zeros{ Float64  }(sâ‚, sâ‚‚))\n\n    B = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, sâ‚‚))\n    C = SparseMatrixCSC(Zeros{ Float64  }(sâ‚, sâ‚‚))\n\n    # -------------------- construct matrix  ------------------------\n    # lhs of the matrix (size := 2 Ã— 2)\n    # eigenvectors: [Ïˆ]\n    âˆ‡â‚•Â² = SparseMatrixCSC(Zeros{Float64}(N, N))\n    âˆ‡â‚•Â² = (1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.k^2 * Iâ°)\n\n    # definition of perturbation PV, q = Dâ‚‚Â³áµˆ{Ïˆ}\n    Dâ‚‚Â³áµˆ = (1.0 * âˆ‡â‚•Â²\n            + 1.0  * mf.âˆ‡á¶»Bâ‚€â»Â¹ * Op.ğ’ŸÂ²á¶»\n            - 1.0  * mf.âˆ‡á¶»á¶»Bâ‚€  * mf.âˆ‡á¶»Bâ‚€â»Â² * Op.ğ’Ÿá¶»)\n\n    # 1. Ïˆ equation\n    ğ“›[:,1:1sâ‚‚] = (1.0im * params.k * mf.Uâ‚€   * Dâ‚‚Â³áµˆ\n                + 1.0im * params.k * mf.âˆ‡Ê¸Qâ‚€ * Iâ° #)\n                - 1.0 * params.E * âˆ‡â‚•Â² * Dâ‚‚Â³áµˆ)\n\n    â„³[:,1:1sâ‚‚] = -1.0 * Dâ‚‚Â³áµˆ\n\n    # Implementing boundary conditions\n    _, zi = ndgrid(1:1:params.Ny, 1:1:params.Nz)\n    zi    = transpose(zi);\n    zi    = zi[:];\n    bcá¶»áµ‡  = findall( x -> (x==1),         zi )\n    bcá¶»áµ—  = findall( x -> (x==params.Nz), zi )\n\n    # Implementing boundary condition for ğ“› matrix in the z-direction:\n    B[:,1:1sâ‚‚] = 1.0im * params.k * mf.Uâ‚€ * Op.ğ’Ÿá¶» - 1.0im * params.k * mf.âˆ‡á¶»Uâ‚€ * Iâ°\n\n    # Bottom boundary condition @ z=0\n    @. ğ“›[bcá¶»áµ‡, :] = B[bcá¶»áµ‡, :]\n\n    # Top boundary condition @ z = 1\n    @. ğ“›[bcá¶»áµ—, :] = B[bcá¶»áµ—, :]\n\n    # Implementing boundary condition for â„³ matrix in the z-direction:\n    C[:,1:1sâ‚‚] = -1.0 * Op.ğ’Ÿá¶»\n\n    # Bottom boundary condition @ z=0\n    @. â„³[bcá¶»áµ‡, :] = C[bcá¶»áµ‡, :]\n\n    # Top boundary condition @ z = 1\n    @. â„³[bcá¶»áµ—, :] = C[bcá¶»áµ—, :]\n\n    return ğ“›, â„³\nend","category":"page"},{"location":"literated/Eady/#Define-the-parameters","page":"Eady","title":"Define the parameters","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 1.0         # horizontal domain size\n    H::T        = 1.0         # vertical domain size\n    Ri::T       = 1.0         # the Richardson number\n    k::T        = 0.0         # x-wavenumber\n    E::T        = 1.0e-16     # Ekman number\n    Ny::Int64   = 50          # no. of y-grid points\n    Nz::Int64   = 30          # no. of z-grid points\n    method::String = \"krylov\"\nend","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"Main.var\"##231\".Params","category":"page"},{"location":"literated/Eady/#Define-the-eigenvalue-solver","page":"Eady","title":"Define the eigenvalue solver","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"function EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    ğ“›, â„³ = construct_matrices(Op, mf, params)\n\n     if params.method == \"shift_invert\"\n        Î»â‚› = EigSolver_shift_invert( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€)\n\n    elseif params.method == \"krylov\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_krylov( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n\n    elseif params.method == \"arnoldi\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arnoldi( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n    end\n    # ======================================================================\n    @assert length(Î»â‚›) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||ğ“›Î§ - Î»â‚›â„³Î§||â‚‚: %f \\n\" norm(ğ“› * Î§[:,1] - Î»â‚›[1] * â„³ * Î§[:,1])\n\n    #@printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(Î»â‚›[1]) imag(Î»â‚›[1])\n\n    return Î»â‚›[1] #, Î§[:,1]\nend","category":"page"},{"location":"literated/Eady/#Solving-the-Eady-(1949)-problem","page":"Eady","title":"Solving the Eady (1949) problem","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"function solve_Eady1949(k::Float64=0.0)\n    params      = Params{Float64}(k=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    mf          = MeanFlow{params.Ny * params.Nz}()\n\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    BasicState!(diffMatrix, mf, grid, params)\n\n    Ïƒâ‚€   = 0.01 # initial guess for the growth rate\n    params.k = k\n\n    Î»â‚› = EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    # Analytical solution of Eady (1949) for the growth rate\n    Î¼  = 1.0 * params.k * âˆšparams.Ri\n    Î»â‚›â‚œ = 1.0/âˆšparams.Ri * âˆš( (coth(0.5Î¼) - 0.5Î¼)*(0.5Î¼ - tanh(0.5Î¼)) )\n\n    @printf \"Analytical solution of Eady (1949) for the growth rate: %f \\n\" Î»â‚›â‚œ\n\n    return abs(Î»â‚›.re - Î»â‚›â‚œ) < 1e-3\n\nend","category":"page"},{"location":"literated/Eady/#Result","page":"Eady","title":"Result","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"solve_Eady1949(0.1) # growth rate is at k=0.1","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"sigma: 0.011500 \n(1500,)\nfound eigenvalue: 0.028829 + im 0.000000 \n||ğ“›Î§ - Î»â‚›â„³Î§||â‚‚: 0.000000 \nAnalytical solution of Eady (1949) for the growth rate: 0.028829 \n","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Linear stability analysis of baroclinic instability of a 2D front based on Stone (1971)","category":"page"},{"location":"literated/Stone1971/#Introduction","page":"Stone1971","title":"Introduction","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Baroclinic instability arises when a rotating, stratified fluid has tilted density surfaces, enabling eddies to tap available potential energy and convert it to kinetic energy. Stone (1971) shows that the classic Eady â€œgeostrophicâ€ baroclinic mode under non-hydrostatic effects, He showed that this effect systematically weakens its growth rate and shifts the most unstable wavelength to larger scales.","category":"page"},{"location":"literated/Stone1971/#Basic-state","page":"Stone1971","title":"Basic state","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The basic state is given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    B(y z) = Ri z - y \n    U(y z) = z - 12\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where Ri is the Richardson number. We aim to analyze the stability of the above basic state against small perturbations. The perturbation variables are defined as","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    mathbfu(x y z t) = (u v epsilon w)(x y z t) \n    p(x y z t) = p(x y z t) \n    b(x y z t) = b(x y z t)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where epsilon is the aspect ratio, mathbfu is the velocity perturbation, p is the pressure perturbation, and b is the buoyancy perturbation.","category":"page"},{"location":"literated/Stone1971/#Governing-equations","page":"Stone1971","title":"Governing equations","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu\n\n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b\n\n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  DDt equiv partialpartial t + U (partialpartial x)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"is the material derivative. The operators:","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracDDtnabla^2 w\n    + frac1epsilon^2 fracpartial zetapartial z\n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta\n\n    fracDbDt\n    + v fracpartial Bpartial y +\n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.","category":"page"},{"location":"literated/Stone1971/#Normal-mode-solutions","page":"Stone1971","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Next we consider normal-mode perturbation solutions in the form of","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew tildezeta tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. The variable sigma=sigma_r + i sigma_i. The real part represents the growth rate, and the imaginary part shows the frequency of the  perturbation.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev +\n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":" mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + (1epsilon^2)partial_z^2 - k^2big)^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"and","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":" mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"literated/Stone1971/#Boundary-conditions","page":"Stone1971","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  tildew = partial_zz tildew =\n  partial_z tildezeta = partial_z tildeb = 0\n   textat  z=0 1\nendalign","category":"page"},{"location":"literated/Stone1971/#Generalized-eigenvalue-problem","page":"Stone1971","title":"Generalized eigenvalue problem","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n AX= Î»BX\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where lambda is the eigenvalue, and X is the eigenvector. The matrices A and B are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    A = beginbmatrix\n        -E mathcalD^4 + i k U mathcalD^2  mathcalD^2  -mathcalD_h^2 \n        -partial_z U partial_y  i k U - E mathcalD^2  0 \n      partial_z B  ik U - E mathcalD^2  0\n    endbmatrix\n\n    B = beginbmatrix\n        epsilon^2 mathcalD^2  0  0 \n        0  I  0 \n        0  0  I\n    endbmatrix\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where I is the identity matrix.","category":"page"},{"location":"literated/Stone1971/#Load-required-packages","page":"Stone1971","title":"Load required packages","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing JLD2\nusing ModelingToolkit\nusing NonlinearSolve\n\nusing BiGSTARS","category":"page"},{"location":"literated/Stone1971/#Define-the-grid-and-derivative-operators","page":"Stone1971","title":"Define the grid and derivative operators","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend\n\n\n@with_kw mutable struct Operator{N}\n    # `subperscript N' means Operator with Neumann boundary condition\n    # `subperscript D' means Operator with Dirchilet boundary condition\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÊ¸á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’ŸÊ¸Â²á¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸Â²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend\n\n@with_kw mutable struct MeanFlow{N}\n    Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n    Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡Ê¸Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»Bâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n\n  âˆ‡Ê¸Ê¸Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡á¶»á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n  âˆ‡Ê¸á¶»Uâ‚€::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\nend","category":"page"},{"location":"literated/Stone1971/#Constructing-the-derivative-operators","page":"Stone1971","title":"Constructing the derivative operators","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function construct_matrices(Op, mf, grid, params)\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # basic state\n    Bâ‚€   = @. 1.0params.Ri * Z - Y\n    âˆ‚Ê¸Bâ‚€ = - 1.0 .* ones(size(Y))\n    âˆ‚á¶»Bâ‚€ = 1.0params.Ri .* ones(size(Y))\n\n    Uâ‚€      = @. 1.0 * Z - 0.5params.H\n    âˆ‚á¶»Uâ‚€    = ones( size(Y))\n    âˆ‚Ê¸Uâ‚€    = zeros(size(Y))\n\n    âˆ‚Ê¸Ê¸Uâ‚€   = zeros(size(Y))\n    âˆ‚Ê¸á¶»Uâ‚€   = zeros(size(Y))\n    âˆ‚á¶»á¶»Uâ‚€   = zeros(size(Y))\n\n      Bâ‚€  = Bâ‚€[:];\n      Uâ‚€  = Uâ‚€[:];\n    âˆ‚Ê¸Bâ‚€  = âˆ‚Ê¸Bâ‚€[:];\n    âˆ‚á¶»Bâ‚€  = âˆ‚á¶»Bâ‚€[:];\n\n    âˆ‚á¶»Uâ‚€  = âˆ‚á¶»Uâ‚€[:];\n    âˆ‚Ê¸Uâ‚€  = âˆ‚Ê¸Uâ‚€[:];\n\n    âˆ‚Ê¸Ê¸Uâ‚€ = âˆ‚Ê¸Ê¸Uâ‚€[:];\n    âˆ‚Ê¸á¶»Uâ‚€ = âˆ‚Ê¸á¶»Uâ‚€[:];\n    âˆ‚á¶»á¶»Uâ‚€ = âˆ‚á¶»á¶»Uâ‚€[:];\n\n    mf.Bâ‚€[diagind(mf.Bâ‚€)] = Bâ‚€\n    mf.Uâ‚€[diagind(mf.Uâ‚€)] = Uâ‚€\n\n    mf.âˆ‡á¶»Uâ‚€[diagind(mf.âˆ‡á¶»Uâ‚€)] = âˆ‚á¶»Uâ‚€\n    mf.âˆ‡Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Uâ‚€)] = âˆ‚Ê¸Uâ‚€\n\n    mf.âˆ‡Ê¸Bâ‚€[diagind(mf.âˆ‡Ê¸Bâ‚€)] = âˆ‚Ê¸Bâ‚€\n    mf.âˆ‡á¶»Bâ‚€[diagind(mf.âˆ‡á¶»Bâ‚€)] = âˆ‚á¶»Bâ‚€\n\n    mf.âˆ‡Ê¸Ê¸Uâ‚€[diagind(mf.âˆ‡Ê¸Ê¸Uâ‚€)] = âˆ‚Ê¸Ê¸Uâ‚€;\n    mf.âˆ‡á¶»á¶»Uâ‚€[diagind(mf.âˆ‡á¶»á¶»Uâ‚€)] = âˆ‚á¶»á¶»Uâ‚€;\n    mf.âˆ‡Ê¸á¶»Uâ‚€[diagind(mf.âˆ‡Ê¸á¶»Uâ‚€)] = âˆ‚Ê¸á¶»Uâ‚€;\n\n    N  = params.Ny * params.Nz\n    Iâ° = sparse(Matrix(1.0I, N, N)) #Eye{Float64}(N)\n    sâ‚ = size(Iâ°, 1); sâ‚‚ = size(Iâ°, 2)\n\n    # allocating memory for the LHS and RHS matrices\n    ğ“›â‚ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚‚ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚ƒ = SparseMatrixCSC(Zeros{ComplexF64}(sâ‚, 3sâ‚‚))\n\n    â„³â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    âˆ‡â‚•Â² = SparseMatrixCSC(Zeros(N, N))\n    H   = SparseMatrixCSC(Zeros(N, N))\n\n    âˆ‡â‚•Â² = (1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.k^2 * Iâ°)\n\n\n    H = inverse_Lap_hor(âˆ‡â‚•Â²)\n    @assert norm(âˆ‡â‚•Â² * H - Iâ°) â‰¤ 1.0e-4 \"difference in L2-norm should be small\"\n\n\n    Dâ´  = (1.0 * Op.ğ’Ÿâ´Ê¸\n        + 1.0/params.Îµ^4 * Op.ğ’Ÿâ´á¶»á´°\n        + 1.0 * params.k^4 * Iâ°\n        - 2.0 * params.k^2 * Op.ğ’ŸÂ²Ê¸\n        - 2.0/params.Îµ^2 * params.k^2 * Op.ğ’ŸÂ²á¶»á´°\n        + 2.0/params.Îµ^2 * Op.ğ’ŸÂ²Ê¸Â²á¶»á´°)\n\n    DÂ²  = (1.0/params.Îµ^2 * Op.ğ’ŸÂ²á¶»á´° + 1.0 * âˆ‡â‚•Â²)\n    Dâ‚™Â² = (1.0/params.Îµ^2 * Op.ğ’ŸÂ²á¶»á´º + 1.0 * âˆ‡â‚•Â²)\n\n    # 1. uá¶» (vertical velocity)  equation (bcs: uá¶» = âˆ‚á¶»á¶»uá¶» = 0 @ z = 0, 1)\n    ğ“›â‚[:,    1:1sâ‚‚] = (-1.0 * params.E * Dâ´\n                    + 1.0im * params.k * mf.Uâ‚€ * DÂ²) * params.Îµ^2\n    ğ“›â‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0 * Op.ğ’Ÿá¶»á´º\n    ğ“›â‚[:,2sâ‚‚+1:3sâ‚‚] = -1.0 * âˆ‡â‚•Â²\n\n    # 2. Ï‰á¶» (vertical vorticity) equation (bcs: âˆ‚á¶»Ï‰á¶» = 0 @ z = 0, 1)\n    ğ“›â‚‚[:,    1:1sâ‚‚] = - 1.0 * mf.âˆ‡á¶»Uâ‚€ * Op.ğ’ŸÊ¸ - 1.0 * Op.ğ’Ÿá¶»á´°\n    ğ“›â‚‚[:,1sâ‚‚+1:2sâ‚‚] = (1.0im * params.k * mf.Uâ‚€ * Iâ° - 1.0 * params.E * Dâ‚™Â²)\n    ğ“›â‚‚[:,2sâ‚‚+1:3sâ‚‚] = 0.0 * Iâ°\n\n    # 3. b (buoyancy) equation (bcs: b = 0 @ z = 0, 1)\n    ğ“›â‚ƒ[:,    1:1sâ‚‚] = (1.0 * mf.âˆ‡á¶»Bâ‚€ * Iâ°\n                    - 1.0 * mf.âˆ‡Ê¸Bâ‚€ * H * Op.ğ’ŸÊ¸á¶»á´°)\n    ğ“›â‚ƒ[:,1sâ‚‚+1:2sâ‚‚] = 1.0im * params.k * mf.âˆ‡Ê¸Bâ‚€ * H * Iâ°\n    ğ“›â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = (-1.0 * params.E * Dâ‚™Â²\n                    + 1.0im * params.k * mf.Uâ‚€ * Iâ°)\n\n    ğ“› = ([ğ“›â‚; ğ“›â‚‚; ğ“›â‚ƒ]);\n\n\n    cnst = -1.0\n    â„³â‚[:,    1:1sâ‚‚] = 1.0cnst * params.Îµ^2 * DÂ²;\n    â„³â‚‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0cnst * Iâ°;\n    â„³â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = 1.0cnst * Iâ°;\n    â„³ = ([â„³â‚; â„³â‚‚; â„³â‚ƒ])\n\n    return ğ“›, â„³\nend","category":"page"},{"location":"literated/Stone1971/#Define-the-parameters","page":"Stone1971","title":"Define the parameters","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 1.0        # horizontal domain size\n    H::T        = 1.0        # vertical domain size\n    Ri::T       = 0.1       # the Richardson number\n    Îµ::T        = 0.1        # aspect ratio Îµ â‰¡ H/L\n    k::T        = 0.0        # x-wavenumber\n    E::T        = 1.0e-9     # Ekman number\n    Ny::Int64   = 48         # no. of y-grid points\n    Nz::Int64   = 24         # no. of z-grid points\n    method::String = \"krylov\"\nend","category":"page"},{"location":"literated/Stone1971/#Define-the-eigenvalue-solver","page":"Stone1971","title":"Define the eigenvalue solver","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    ğ“›, â„³ = construct_matrices(Op, mf, grid, params)\n\n    if params.method == \"shift_invert\"\n        Î»â‚› = EigSolver_shift_invert( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€)\n\n    elseif params.method == \"krylov\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_krylov( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n\n    elseif params.method == \"arnoldi\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arnoldi( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LR)\n    end\n    # ======================================================================\n    @assert length(Î»â‚›) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||ğ“›Î§ - Î»â‚›â„³Î§||â‚‚: %f \\n\" norm(ğ“› * Î§[:,1] - Î»â‚›[1] * â„³ * Î§[:,1])\n\n    @printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(Î»â‚›[1]) imag(Î»â‚›[1])\n\n    return Î»â‚›[1] #, Î§[:,1]\nend","category":"page"},{"location":"literated/Stone1971/#Solving-the-Stone-problem","page":"Stone1971","title":"Solving the Stone problem","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function solve_Stone1971(k::Float64=0.0)\n    params      = Params{Float64}(k=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    mf          = MeanFlow{params.Ny * params.Nz}()\n\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    Ïƒâ‚€   = 0.02 # initial guess for the growth rate\n    params.k = k\n\n    Î»â‚› = EigSolver(Op, mf, grid, params, Ïƒâ‚€)\n\n    # Analytical solution of Stone (1971) for the growth rate\n    cnst = 1.0 + 1.0 * params.Ri + 5.0 * params.Îµ^2 * params.k^2 / 42.0\n    Î»â‚›â‚œ = 1.0 / (2.0 * âˆš3.0) * (params.k - 2.0 / 15.0 * params.k^3 * cnst)\n\n    @printf \"Analytical solution of Stone (1971) for the growth rate: %f \\n\" Î»â‚›â‚œ\n\n    return abs(Î»â‚›.re - Î»â‚›â‚œ) < 1e-3\n\nend","category":"page"},{"location":"literated/Stone1971/#Result","page":"Stone1971","title":"Result","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"solve_Stone1971(0.1) # growth rate is at k=0.1","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"sigma: 0.023000 \n(3456, 10)\nfound eigenvalue: 0.028831 + im 0.000000 \n||ğ“›Î§ - Î»â‚›â„³Î§||â‚‚: 0.000171 \nlargest growth rate : 2.8831e-02+2.4577e-11im\nAnalytical solution of Stone (1971) for the growth rate: 0.028825 \n","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"This page was generated using Literate.jl.","category":"page"},{"location":"matrices/#Construction-of-differentiation-matrices","page":"Differentiation matrix","title":"Construction of differentiation matrices","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"This page documents the core spectralâ€matrix routines in BiGSTARS.jl.","category":"page"},{"location":"matrices/#Chebyshev-differentiation-matrix","page":"Differentiation matrix","title":"Chebyshev differentiation matrix","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"A standard approach is followed in the construction of the differentiation matrices  \\citep{trefethen2000spectral}. The transformed Gaussâ€“Lobatto points for  z in 0 1 are given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginalign\n    z_j = frac12 cos(jpiN_z) + frac12\n    \n    j = 0 cdots N_z\nendalign","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and the first-order Chebyshev differentiation matrix is given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n  (mathrmD_z)_ij = begincases\n     dfrac2N_z^2+13   i=j=0 \n\n    dfracc_ic_j dfrac(-1)^i+jz_i-z_j\n      i neq j\n      c_i\n     begincases \n        2  i=0N_z \n        1  textotherwise\n     endcases\n\n    dfrac-cos(jpiN_z)1-cos^2(jpiN_z)\n     0  i = j  N_z\n\n    -dfrac2N_z^2+13  i=j=N_z\n  endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Chebyshev differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN = 10 # number of grid points\nz, D = cheb(N-1)\n\nnothing # hide","category":"page"},{"location":"matrices/#Fourier-differentiation-matrix","page":"Differentiation matrix","title":"Fourier differentiation matrix","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"For y in 0L_y, the first-order Fourier differentiation matrix for even N_y is,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cotleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and for odd N_y,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cscleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"where h=2piN_y.","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Fourier differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN    = 10 # number of grid points\nmder = 1  # order of Fourier derivative\ny, D = FourierDiff(N, mder)\n\nThe domain size of `y` is 0 to 2Ï€.\nTo convert into an arbitrary domain [0, L]: \n\ny0 = L/(2Ï€) * y\nğ’Ÿ = (2Ï€/L)^1 * D\n\nFor an n-th derivative:\n\ny, D = FourierDiff(N, n)\nğ’Ÿ   = (2Ï€/L)^n * D\n\n\nnothing # hide","category":"page"},{"location":"method/#Shift-and-Invert-Method","page":"Methodology","title":"Shift and Invert Method","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"The shift-and-invert transformation is a common technique for solving the generalized eigenvalue problem","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"A X = lambda B X","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"by focusing on eigenvalues near a target shift sigma:","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"(A - sigma B)^-1 B X = mu X\nquad mu = (lambda - sigma)^-1","category":"page"},{"location":"method/#Key-Advantages","page":"Methodology","title":"Key Advantages","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Selective targeting: Eigenvalues lambda closest to sigma correspond to the largest magnitudes of mu, enabling efficient extraction via Krylov solvers (e.g., Arnoldi, Lanczos).\nAccelerated convergence: Inverting the shifted operator (A - sigma B) compresses the spectrum so that desired eigenmodes dominate.","category":"page"},{"location":"method/#Algorithm-Outline","page":"Methodology","title":"Algorithm Outline","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Select a shift sigma near the eigenvalue of interest.\nFactor or set up an efficient solver for A - sigma B (e.g., LU, sparse direct, or preconditioned iterative solver).\nIterate with a Krylov-based eigensolver on (A - sigma B)^-1 B to compute mu.\nRecover the original eigenvalue:\nlambda = sigma + mu^-1","category":"page"},{"location":"literated/rRBC/#Finding-critical-Rayleigh-number-for-rotating-Rayleigh-Benard-Convection","page":"rRBC","title":"Finding critical Rayleigh number for rotating Rayleigh-Benard Convection","text":"","category":"section"},{"location":"literated/rRBC/#Introduction","page":"rRBC","title":"Introduction","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"This code finds critical Rayleigh number for the onset of convection for rotating Rayleigh Benrad Convection (rRBC) where the domain is periodic in y-direction. The code is benchmarked against Chandrashekar's theoretical results. Hydrodynamic and hydromagnetic stability by S. Chandrasekhar, 1961 (page no-95).","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Parameter:","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Ekman number E = 10â´","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Eigenvalue: critical modified Rayleigh number Ra_c = 1897","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"In this module, we do a linear stability analysis of a 2D rotating Rayleigh-Bernard case where the domain is periodic in the y-direction, in the x-direction is of infinite extent and vertically bounded. The reason to choose this simple case is because we can find an analytical solution for this case.","category":"page"},{"location":"literated/rRBC/#Basic-state","page":"rRBC","title":"Basic state","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The background temperature profile overlinetheta is given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"overlinetheta = 1 - z","category":"page"},{"location":"literated/rRBC/#Governing-equations","page":"rRBC","title":"Governing equations","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The non-dimensional form of the equations governing the perturbation is given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    fracEPr fracpartial mathbfupartial t\n    + hatz times mathbfu =\n    -nabla p + Ra theta hatz + E nabla^2 mathbfu","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    fracpartial thetapartial t\n    = mathbfu cdot hatz + nabla^2 theta","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    nabla cdot mathbfu = 0","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where E=nu(fH^2) is the Ekman number and Ra = galpha Delta T(f kappa), Delta T is the temperature difference between the bottom and the top walls) is the modified Rayleigh number. By applying the operators (nabla times nabla times) and (nabla times) and taking the z-component of the equations and assuming wave-like perturbations, we obtained the equations for vertical velocity w, vertical vorticity zeta and temperature theta,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    E mathcalD^4 w - partial_z zeta = -Ra mathcalD_h^2 theta\n\n    E mathcalD^2 zeta + partial_z w = 0\n\n    mathcalD^2 b + w = 0\nendalign","category":"page"},{"location":"literated/rRBC/#Normal-mode-solutions","page":"rRBC","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Next we consider normal-mode perturbation solutions in the form of (we seek stationary solutions at the marginal state, i.e., sigma = 0),","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n w zeta theta(xyzt) = mathfrakRbig(tildew tildezeta tildetheta(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    E mathcalD^4  tildew - partial_z tildezeta = - Ra mathcalD_h^2 tildetheta\n\n    E mathcalD^2 tildezeta + partial_z tildew = 0\n\n    mathcalD^2 tildetheta + tildew = 0\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\nmathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + partial_z^2 - k^2big)^2\n textand  mathcalD_h^2 = (partial_y^2 - k^2)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n\n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"literated/rRBC/#Boundary-conditions","page":"rRBC","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    tildew = partial_zz tildew =\n    partial_z tildezeta = partial_z tildeb = 0\n     textat  z=0 1\nendalign","category":"page"},{"location":"literated/rRBC/#Generalized-eigenvalue-problem","page":"rRBC","title":"Generalized eigenvalue problem","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n AX= Î»BX\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where lambda=Ra is the eigenvalue, and X is the eigenvector, The matrices A and B are given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    A = beginbmatrix\n        -E mathcalD^4  0  Ra mathcalD_h^2 \n        0  -E mathcalD^2  -partial\n        partial_z  0 \n        0  partial_z  mathcalD^2\n    endbmatrix\n\n    B = beginbmatrix\n        mathcalD_h^2  0  0 \n        0  mathcalD_h^2  0 \n        0  0  I\n    endbmatrix\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where I is the identity matrix.","category":"page"},{"location":"literated/rRBC/#Load-required-packages","page":"rRBC","title":"Load required packages","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing ArnoldiMethod: partialschur, partialeigen, LR, LI, LM, SR","category":"page"},{"location":"literated/rRBC/#Let's-begin","page":"rRBC","title":"Let's begin","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"using BiGSTARS","category":"page"},{"location":"literated/rRBC/#Define-the-grid-and-derivative-operators","page":"rRBC","title":"Define the grid and derivative operators","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"@with_kw mutable struct TwoDimGrid{Ny, Nz}\n    y = @SVector zeros(Float64, Ny)\n    z = @SVector zeros(Float64, Nz)\nend\n\n@with_kw mutable struct ChebMarix{Ny, Nz}\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Ny, Ny))\n\n    ğ’Ÿá¶»::Array{Float64,  2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»::Array{Float64, 2}   = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(Nz, Nz))\nend\n\n\n@with_kw mutable struct Operator{N}\n    # `subperscript N' means Operator with Neumann boundary condition\n    # `subperscript D' means Operator with Dirchilet boundary condition\n    ğ’ŸÊ¸::Array{Float64,  2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´Ê¸::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´º::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´º::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’Ÿá¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÊ¸á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’Ÿâ´á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\n\n    ğ’ŸÊ¸Â²á¶»á´°::Array{Float64,  2}  = SparseMatrixCSC(Zeros(N, N))\n    ğ’ŸÂ²Ê¸Â²á¶»á´°::Array{Float64, 2}  = SparseMatrixCSC(Zeros(N, N))\nend\n\nfunction construct_matrices(Op, params)\n    N  = params.Ny * params.Nz\n    Iâ° = sparse(Matrix(1.0I, N, N)) #Eye{Float64}(N)\n    sâ‚ = size(Iâ°, 1); sâ‚‚ = size(Iâ°, 2)\n\n    # allocating memory for the LHS and RHS matrices\n    ğ“›â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    ğ“›â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    â„³â‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚‚ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n    â„³â‚ƒ = SparseMatrixCSC(Zeros{Float64}(sâ‚, 3sâ‚‚))\n\n    @printf \"Start constructing matrices \\n\"\n    # -------------------- construct matrix  ------------------------\n    # lhs of the matrix (size := 3 Ã— 3)\n    # eigenvectors: [uá¶» Ï‰á¶» Î¸]áµ€\n\n    âˆ‡â‚•Â² = SparseMatrixCSC(Zeros(N, N))\n    âˆ‡â‚•Â² = (1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.k^2 * Iâ°)\n\n    Dâ´ = (1.0 * Op.ğ’Ÿâ´Ê¸ + 1.0 * Op.ğ’Ÿâ´á¶»á´° + 2.0 * Op.ğ’ŸÂ²Ê¸Â²á¶»á´°\n        + 1.0 * params.k^4 * Iâ°\n        - 2.0 * params.k^2 * Op.ğ’ŸÂ²Ê¸\n        - 2.0 * params.k^2 * Op.ğ’ŸÂ²á¶»á´°)\n\n    DÂ²  = 1.0 * Op.ğ’ŸÂ²á¶»á´° + 1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.k^2 * Iâ°\n    Dâ‚™Â² = 1.0 * Op.ğ’ŸÂ²á¶»á´º + 1.0 * Op.ğ’ŸÂ²Ê¸ - 1.0 * params.k^2 * Iâ°\n\n    # 1. uá¶» (vertical velocity) equation\n    ğ“›â‚[:,    1:1sâ‚‚] =  1.0 * params.E * Dâ´\n    ğ“›â‚[:,1sâ‚‚+1:2sâ‚‚] = -1.0 * Op.ğ’Ÿá¶»á´º\n    ğ“›â‚[:,2sâ‚‚+1:3sâ‚‚] =  0.0 * Iâ°\n\n    # 2. Ï‰á¶» (vertical vorticity) equation\n    ğ“›â‚‚[:,    1:1sâ‚‚] = 1.0 * Op.ğ’Ÿá¶»á´°\n    ğ“›â‚‚[:,1sâ‚‚+1:2sâ‚‚] = 1.0 * params.E * Dâ‚™Â²\n    ğ“›â‚‚[:,2sâ‚‚+1:3sâ‚‚] = 0.0 * Iâ°\n\n    # 3. Î¸ (temperature) equation\n    ğ“›â‚ƒ[:,    1:1sâ‚‚] = 1.0 * Iâ°\n    ğ“›â‚ƒ[:,1sâ‚‚+1:2sâ‚‚] = 0.0 * Iâ°\n    ğ“›â‚ƒ[:,2sâ‚‚+1:3sâ‚‚] = 1.0 * DÂ²\n\n    ğ“› = ([ğ“›â‚; ğ“›â‚‚; ğ“›â‚ƒ]);\n\n\n    â„³â‚[:,2sâ‚‚+1:3sâ‚‚] = -1.0 * âˆ‡â‚•Â²\n\n    â„³ = ([â„³â‚; â„³â‚‚; â„³â‚ƒ])\n\n    return ğ“›, â„³\nend","category":"page"},{"location":"literated/rRBC/#Define-the-parameters","page":"rRBC","title":"Define the parameters","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"@with_kw mutable struct Params{T<:Real} @deftype T\n    L::T        = 2Ï€          # horizontal domain size\n    H::T        = 1.0         # vertical domain size\n    k::T        = 0.0         # x-wavenumber\n    E::T        = 1.0e-4      # Ekman number\n    Ny::Int64   = 280         # no. of y-grid points\n    Nz::Int64   = 18          # no. of z-grid points\n    method::String   = \"arnoldi\"\nend","category":"page"},{"location":"literated/rRBC/#Define-the-eigenvalue-solver","page":"rRBC","title":"Define the eigenvalue solver","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function EigSolver(Op, params, Ïƒâ‚€)\n\n    ğ“›, â„³ = construct_matrices(Op,  params)\n\n    N = params.Ny * params.Nz\n    MatrixSize = 3N\n    @assert size(ğ“›, 1)  == MatrixSize &&\n            size(ğ“›, 2)  == MatrixSize &&\n            size(â„³, 1)  == MatrixSize &&\n            size(â„³, 2)  == MatrixSize \"matrix size does not match!\"\n\n    if params.method == \"shift_invert\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arpack( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LM)\n\n    elseif params.method == \"krylov\"\n\n         Î»â‚›, Î§ = EigSolver_shift_invert_krylov( ğ“›, â„³, Ïƒâ‚€=Ïƒâ‚€, maxiter=40, which=:LM)\n\n    elseif params.method == \"arnoldi\"\n\n        Î»â‚›, Î§ = EigSolver_shift_invert_arnoldi( ğ“›, â„³,\n                                            Ïƒâ‚€=0.0,\n                                            maxiter=50000,\n                                            which=LM())\n\n        Î»â‚›, Î§ = remove_evals(Î»â‚›, Î§, 10.0, 1.0e15, \"R\")\n        Î»â‚›, Î§ = sort_evals(Î»â‚›, Î§, \"R\", \"\")\n\n    end\n\n    @printf \"Obtained critical Ra: %f \\n\" real(Î»â‚›[1])\n\n    return Î»â‚›[1] #, Î§[:,1]\nend","category":"page"},{"location":"literated/rRBC/#solving-the-rRBC-problem","page":"rRBC","title":"solving the rRBC problem","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function solve_rRBC(k::Float64)\n    params      = Params{Float64}(k=0.5)\n    grid        = TwoDimGrid{params.Ny,  params.Nz}()\n    diffMatrix  = ChebMarix{ params.Ny,  params.Nz}()\n    Op          = Operator{params.Ny * params.Nz}()\n    Construct_DerivativeOperator!(diffMatrix, grid, params)\n    ImplementBCs_cheb!(Op, diffMatrix, params)\n\n    Ïƒâ‚€   = 0.0\n    params.k = k\n\n    Î»â‚› = EigSolver(Op, params, Ïƒâ‚€)\n\n    # Theoretical results from Chandrashekar (1961)\n    Î»â‚›â‚œ = 189.7\n\n    @printf \"Analytical solution of critical Ra: %f \\n\" Î»â‚›â‚œ\n\n    return abs(real(Î»â‚›) - Î»â‚›â‚œ)/Î»â‚›â‚œ < 1e-4\n\nend","category":"page"},{"location":"literated/rRBC/#Result","page":"rRBC","title":"Result","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"solve_rRBC(0.0) # Critical Rayleigh number is at k=0.0","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Start constructing matrices \nsigma: 0.000000 \nConverged: 20 of 20 eigenvalues in 151 matrix-vector products\nObtained critical Ra: 189.704088 \nAnalytical solution of critical Ra: 189.700000 \n","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#BiGSTARS.jl-Documentation","page":"Home","title":"BiGSTARS.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BiGSTARS.jl:A Julia toolkit for bi-global linear stability analysis for geophysical flows using Chebyshev-Fourier spectral collocation method.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples aim to demonstrate the main functionalities of each module. Have a look at our Examples collection!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stone1971 example\nEady example\nrRBC example","category":"page"}]
}
