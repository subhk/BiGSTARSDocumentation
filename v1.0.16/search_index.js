var documenterSearchIndex = {"docs":
[{"location":"matrices/#Construction-of-differentiation-matrices","page":"Differentiation matrix","title":"Construction of differentiation matrices","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"This page documents the core spectral‚Äêmatrix routines in BiGSTARS.jl.","category":"page"},{"location":"matrices/#Chebyshev-differentiation-matrix","page":"Differentiation matrix","title":"Chebyshev differentiation matrix","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"A standard approach is followed in the construction of the differentiation matrices  \\citep{trefethen2000spectral}. The transformed Gauss‚ÄìLobatto points for  z in 0 1 are given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginalign\n    z_j = frac12 cos(jpiN_z) + frac12\n    \n    j = 0 cdots N_z\nendalign","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and the first-order Chebyshev differentiation matrix is given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n  (mathrmD_z)_ij = begincases\n     dfrac2N_z^2+13   i=j=0 \n\n    dfracc_ic_j dfrac(-1)^i+jz_i-z_j\n      i neq j\n      c_i\n     begincases \n        2  i=0N_z \n        1  textotherwise\n     endcases\n\n    dfrac-cos(jpiN_z)1-cos^2(jpiN_z)\n     0  i = j  N_z\n\n    -dfrac2N_z^2+13  i=j=N_z\n  endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Chebyshev differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN = 10 # number of grid points\nz, D = cheb(N-1)\n\nnothing # hide","category":"page"},{"location":"matrices/#Fourier-differentiation-matrix","page":"Differentiation matrix","title":"Fourier differentiation matrix","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"For y in 0L_y, the first-order Fourier differentiation matrix for even N_y is,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cotleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and for odd N_y,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cscleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"where h=2piN_y.","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Fourier differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN    = 10 # number of grid points\nmder = 1  # order of Fourier derivative\ny, D = FourierDiff(N, mder)\n\nThe domain size of `y` is 0 to 2œÄ.\nTo convert into an arbitrary domain [0, L]: \n\ny0 = L/(2œÄ) * y\nùíü = (2œÄ/L)^1 * D\n\nFor an n-th derivative:\n\ny, D = FourierDiff(N, n)\nùíü   = (2œÄ/L)^n * D\n\n\nnothing # hide","category":"page"},{"location":"modules/BiGSTARS/","page":"‚Ä¶other functions‚Ä¶","title":"‚Ä¶other functions‚Ä¶","text":"```@autodocs Modules = [BiGSTARS] Order = [   FourierDiff,   FourierDifffdm,   chebdif,   chebcoordtransform,   chebcoordtransformho,","category":"page"},{"location":"modules/BiGSTARS/#‚Ä¶other-functions‚Ä¶","page":"‚Ä¶other functions‚Ä¶","title":"‚Ä¶other functions‚Ä¶","text":"","category":"section"},{"location":"modules/BiGSTARS/","page":"‚Ä¶other functions‚Ä¶","title":"‚Ä¶other functions‚Ä¶","text":"]","category":"page"},{"location":"method/#Shift-and-Invert-Method","page":"Methodology","title":"Shift and Invert Method","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"The shift-and-invert transformation is a common technique for solving the generalized eigenvalue problem","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"A X = lambda B X","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"by focusing on eigenvalues near a target shift sigma:","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"(A - sigma B)^-1 B X = mu X\nquad mu = (lambda - sigma)^-1","category":"page"},{"location":"method/#Key-Advantages","page":"Methodology","title":"Key Advantages","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Selective targeting: Eigenvalues lambda closest to sigma correspond to the largest magnitudes of mu, enabling efficient extraction via Krylov solvers (e.g., Arnoldi, Lanczos).\nAccelerated convergence: Inverting the shifted operator (A - sigma B) compresses the spectrum so that desired eigenmodes dominate.","category":"page"},{"location":"method/#Algorithm-Outline","page":"Methodology","title":"Algorithm Outline","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Select a shift sigma near the eigenvalue of interest.\nFactor or set up an efficient solver for A - sigma B (e.g., LU, sparse direct, or preconditioned iterative solver).\nIterate with a Krylov-based eigensolver on (A - sigma B)^-1 B to compute mu.\nRecover the original eigenvalue:\nlambda = sigma + mu^-1","category":"page"},{"location":"literated/Stone1971/#Linear-stability-analysis-of-baroclinic-instability-of-a-2D-front-based-on-Stone-(1971)","page":"Stone1971","title":"Linear stability analysis of baroclinic instability of a 2D front based on Stone (1971)","text":"","category":"section"},{"location":"literated/Stone1971/#Introduction","page":"Stone1971","title":"Introduction","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Baroclinic instability (BCI) arises when a rotating, stratified fluid has tilted density surfaces, enabling eddies to tap available potential energy and convert it to kinetic energy. Stone (1971) investigated non-hydrostatic effects on BCI using Eady‚Äôs framework. He found that as the Ri decreases, the wavelength of the most unstable mode increases while the growth rate diminishes relative to predictions from the quasigeostrophic (QG) approximation.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The basic state is given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    B(y z) = Ri z - y \n    U(y z) = z - 12\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where Ri is the Richardson number. We aim to analyze the stability of the above basic state against small perturbations. The perturbation variables are defined as","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    mathbfu(x y z t) = (u v epsilon w)(x y z t) \n    p(x y z t) = p(x y z t) \n    b(x y z t) = b(x y z t)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where epsilon is the aspect ratio, mathbfu is the velocity perturbation, p is the pressure perturbation, and b is the buoyancy perturbation.","category":"page"},{"location":"literated/Stone1971/#Governing-equations","page":"Stone1971","title":"Governing equations","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu\n\n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b\n\n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  DDt equiv partialpartial t + U (partialpartial x)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"is the material derivative. The operators:","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracDDtnabla^2 w\n    + frac1epsilon^2 fracpartial zetapartial z\n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta\n\n    fracDbDt\n    + v fracpartial Bpartial y +\n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.","category":"page"},{"location":"literated/Stone1971/#Normal-mode-solutions","page":"Stone1971","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Next we consider normal-mode perturbation solutions in the form of","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew tildezeta tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. The variable sigma=sigma_r + i sigma_i. The real part represents the growth rate, and the imaginary part shows the frequency of the  perturbation.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev +\n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":" mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + (1epsilon^2)partial_z^2 - k^2big)^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"and","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":" mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"literated/Stone1971/#Boundary-conditions","page":"Stone1971","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  tildew = partial_zz tildew =\n  partial_z tildezeta = partial_z tildeb = 0\n   textat  z=0 1\nendalign","category":"page"},{"location":"literated/Stone1971/#Generalized-eigenvalue-problem","page":"Stone1971","title":"Generalized eigenvalue problem","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem (GEVP),","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n AX= ŒªBX\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where lambda is the eigenvalue, and X is the eigenvector. The matrices A and B are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    A = beginbmatrix\n        epsilon^2(i k U mathcalD^2 -E mathcalD^4)\n          mathcalD_z   -mathcalD_h^2\n  \n        -partial_z U mathcalD_y - mathcalD_z\n           i k U - E mathcalD^2  0\n \n      partial_z B -  partial_y B H mathcalD_yz\n        k partial_y B H   ikU - E mathcalD^2\n    endbmatrix\n\n    B = beginbmatrix\n        epsilon^2 mathcalD^2  0  0 \n        0  I  0 \n        0  0  I\n    endbmatrix\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where I is the identity matrix and H is the inverse of the horizontal Laplacian (mathcalD_h^2)^-1.","category":"page"},{"location":"literated/Stone1971/#Load-required-packages","page":"Stone1971","title":"Load required packages","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing JLD2\nusing Parameters: @with_kw\n\nusing BiGSTARS\nusing BiGSTARS: AbstractParams\nusing BiGSTARS: Problem, OperatorI, TwoDGrid","category":"page"},{"location":"literated/Stone1971/#Parameters","page":"Stone1971","title":"Parameters","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"@with_kw mutable struct Params{T} <: AbstractParams\n    L::T                = 1.0           # horizontal domain size\n    H::T                = 1.0           # vertical domain size\n    Ri::T               = 1.0           # the Richardson number\n    Œµ::T                = 0.1           # aspect ratio Œµ ‚â° H/L\n    k::T                = 0.1           # along-front wavenumber\n    E::T                = 1.0e-8        # the Ekman number\n    Ny::Int64           = 20            # no. of y-grid points\n    Nz::Int64           = 20            # no. of z-grid points\n    w_bc::String        = \"rigid_lid\"   # boundary condition for vertical velocity\n    Œ∂_bc::String        = \"free_slip\"   # boundary condition for vertical vorticity\n    b_bc::String        = \"zero_flux\"   # boundary condition for buoyancy\n    eig_solver::String  = \"arpack\"      # eigenvalue solver\nend","category":"page"},{"location":"literated/Stone1971/#Basic-state","page":"Stone1971","title":"Basic state","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function basic_state(grid, params)\n\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # Define the basic state\n    B‚ÇÄ   = @. params.Ri * Z - Y          # buoyancy\n    U‚ÇÄ   = @. 1.0 * Z - 0.5 * params.H   # along-front velocity\n\n    # Calculate all the necessary derivatives\n    deriv = compute_derivatives(U‚ÇÄ, B‚ÇÄ, grid.y, grid.D·∂ª, grid.D¬≤·∂ª, :All)\n\n    bs = initialize_basic_state_from_fields(B‚ÇÄ, U‚ÇÄ)\n\n    initialize_basic_state!(\n            bs,\n            deriv.‚àÇ ∏B‚ÇÄ,  deriv.‚àÇ·∂ªB‚ÇÄ,\n            deriv.‚àÇ ∏U‚ÇÄ,  deriv.‚àÇ·∂ªU‚ÇÄ,\n            deriv.‚àÇ ∏ ∏U‚ÇÄ, deriv.‚àÇ·∂ª·∂ªU‚ÇÄ, deriv.‚àÇ ∏·∂ªU‚ÇÄ,\n            deriv.‚àÇ ∏ ∏B‚ÇÄ, deriv.‚àÇ·∂ª·∂ªB‚ÇÄ, deriv.‚àÇ ∏·∂ªB‚ÇÄ\n        )\n\n    return bs\nend","category":"page"},{"location":"literated/Stone1971/#Constructing-Generalized-EVP","page":"Stone1971","title":"Constructing Generalized EVP","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function generalized_EigValProb(prob, grid, params)\n\n    bs = basic_state(grid, params)\n\n    N  = params.Ny * params.Nz\n    I‚Å∞ = sparse(Matrix(1.0I, N, N))\n    s‚ÇÅ = size(I‚Å∞, 1);\n    s‚ÇÇ = size(I‚Å∞, 2);\n\n    # the horizontal Laplacian operator\n    ‚àá‚Çï¬≤ = SparseMatrixCSC(Zeros(N, N))\n    ‚àá‚Çï¬≤ = (1.0 * prob.D¬≤ ∏ - 1.0 * params.k^2 * I‚Å∞)\n\n    # inverse of the horizontal Laplacian operator\n    H = inverse_Lap_hor(‚àá‚Çï¬≤)\n\n    # Construct the 4th order derivative\n    D‚Å¥  = (1.0 * prob.D‚Å¥ ∏\n        + 1.0/params.Œµ^4 * prob.D‚Å¥·∂ª·¥∞\n        + 1.0 * params.k^4 * I‚Å∞\n        - 2.0 * params.k^2 * prob.D¬≤ ∏\n        - 2.0/params.Œµ^2 * params.k^2 * prob.D¬≤·∂ª·¥∞\n        + 2.0/params.Œµ^2 * prob.D¬≤ ∏¬≤·∂ª·¥∞)\n\n    # Construct the 2nd order derivative\n    D¬≤  = (1.0/params.Œµ^2 * prob.D¬≤·∂ª·¥∞ + 1.0 * ‚àá‚Çï¬≤)\n    D‚Çô¬≤ = (1.0/params.Œµ^2 * prob.D¬≤·∂ª·¥∫ + 1.0 * ‚àá‚Çï¬≤)\n\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # 1) Now define your 3√ó3 block-rows in a NamedTuple of 3-tuples\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # Construct the matrix `A`\n    Ablocks = (\n        w = (  # w-equation: [z‚Å¥+z¬≤], [‚àÇ·∂ª Neumann], [‚Äì‚àá‚Çï¬≤]\n                sparse(complex.(-params.E * D‚Å¥ + 1.0im * params.k * bs.fields.U‚ÇÄ * D¬≤) * params.Œµ^2),\n                sparse(complex.(prob.D·∂ª·¥∫)),\n                sparse(complex.(-‚àá‚Çï¬≤))\n        ),\n        Œ∂ = (  # Œ∂-equation: [‚àÇ·∂ªU + Dirichlet], [kU‚ÄìEk], [zero]\n                sparse(complex.(-bs.fields.‚àÇ·∂ªU‚ÇÄ * prob.D ∏ - prob.D·∂ª·¥∞)),\n                sparse(complex.(1.0im *params.k * bs.fields.U‚ÇÄ * I‚Å∞ - params.E * D‚Çô¬≤)),\n                spzeros(ComplexF64, s‚ÇÅ, s‚ÇÇ)\n        ),\n        b = (  # b-equation: [‚àÇ·∂ªB ‚Äì D ∏·∂ª·¥∞], [k‚àÇ ∏B], [‚ÄìEk + kU]\n                sparse(complex.(bs.fields.‚àÇ·∂ªB‚ÇÄ * I‚Å∞ - bs.fields.‚àÇ ∏B‚ÇÄ * params.H * prob.D ∏·∂ª·¥∞)),\n                sparse(1.0im * params.k * bs.fields.‚àÇ ∏B‚ÇÄ * params.H * I‚Å∞),\n                sparse(-params.E * D‚Çô¬≤ + 1.0im * params.k * bs.fields.U‚ÇÄ *I‚Å∞)\n        )\n    )\n\n    # Construct the matrix `A`\n    Bblocks = (\n        w = (  # w-equation mass: [‚ÄìŒµ¬≤‚àÇ¬≤], zero, zero\n                sparse(-params.Œµ^2 * D¬≤),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ)\n        ),\n        Œ∂ = (  # Œ∂-equation mass: zero, [‚ÄìI], zero\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                sparse(-I‚Å∞),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ)\n        ),\n        b = (  # b-equation mass: zero, zero, [‚ÄìI]\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                sparse(-I‚Å∞)\n        )\n    )\n\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # 2) Assemble in beautiful line\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    gevp = GEVPMatrices(Ablocks, Bblocks)\n\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # 3) And now you have exactly:\n    #    gevp.A, gevp.B                    ‚Üí full sparse matrices\n    #    gevp.As.w, gevp.As.Œ∂, gevp.As.b   ‚Üí each block-row view of matrix A\n    #    gevp.Bs.w, gevp.Bs.Œ∂, gevp.Bs.b   ‚Üí each block-row view of matrix B\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n    return gevp.A, gevp.B\nend","category":"page"},{"location":"literated/Stone1971/#Eigenvalue-solver","page":"Stone1971","title":"Eigenvalue solver","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function EigSolver(prob, grid, params, œÉ‚ÇÄ)\n\n    A, B = generalized_EigValProb(prob, grid, params)\n\n    if params.eig_solver == \"arpack\"\n        Œª, Œß = solve_shift_invert_arnoldi(A, B; œÉ‚ÇÄ=œÉ‚ÇÄ, which=:LR, sortby=:R)\n\n    elseif params.eig_solver == \"krylov\"\n\n        Œª, Œß = solve_shift_invert_krylov(A, B; œÉ‚ÇÄ=œÉ‚ÇÄ, which=:LR)\n\n    elseif params.eig_solver == \"arnoldi\"\n\n        Œª, Œß = solve_shift_invert_arnoldi(A, B; œÉ‚ÇÄ=œÉ‚ÇÄ, which=:LR)\n    end\n    # ======================================================================\n    @assert length(Œª) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||AŒß - ŒªBŒß||‚ÇÇ: %f \\n\" norm(A * Œß[:,1] - Œª[1] * B * Œß[:,1])\n\n    @printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(Œª[1]) imag(Œª[1])\n\n    return Œª[1], Œß[:,1]\nend","category":"page"},{"location":"literated/Stone1971/#Solving-the-problem","page":"Stone1971","title":"Solving the problem","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function solve_Stone1971(k::Float64)\n\n    # Calling problem parameters\n    params = Params{Float64}()\n\n    # Construct grid and derivative operators\n    grid  = TwoDGrid(params)\n\n    # Construct the necesary operator\n    ops  = OperatorI(params)\n    prob = Problem(grid, ops)\n\n    # update the wavenumber\n    params.k = k\n\n    # initial guess for the growth rate\n    œÉ‚ÇÄ   = 0.02\n\n    Œª, Œß = EigSolver(prob, grid, params, œÉ‚ÇÄ)\n\n    # Analytical solution of Eady (1949) for the growth rate\n    Œº  = 1.0 * params.k * ‚àöparams.Ri\n    Œª‚Çú = 1.0/‚àöparams.Ri * ‚àö( (coth(0.5Œº) - 0.5Œº)*(0.5Œº - tanh(0.5Œº)) )\n\n    @printf \"Analytical solution of Eady (1949) for the growth rate: %f \\n\" Œª‚Çú\n\n    return abs(Œª.re - Œª‚Çú) < 1e-3\n\nend","category":"page"},{"location":"literated/Stone1971/#Result","page":"Stone1971","title":"Result","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"solve_Stone1971(0.1) # growth rate is at k=0.1","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"(attempt  1) trying œÉ = 0.024000\nConverged: first Œª = 0.041563 + i 0.000000 (œÉ = 0.024000)\n(attempt  2) trying œÉ = 0.024800\nConverged: first Œª = 0.041563 + i -0.000000 (œÉ = 0.024800)\nSuccessive eigenvalues converged: |ŒîŒª| = 5.21e-12 < 1.00e-05\n||AŒß - ŒªBŒß||‚ÇÇ: 0.000000 \nlargest growth rate : 4.1563e-02-5.2879e-13im\nAnalytical solution of Eady (1949) for the growth rate: 0.028829 \n","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributors'-Guide","page":"Contributor's Guide","title":"Contributors' Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"This is a short guide for potential BiGSTARS.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"We welcome contributions and questions! If you‚Äôd like to get involved, please don‚Äôt hesitate to  open an issue to start a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"Thank you for helping improve BiGSTARS.jl!","category":"page"},{"location":"modules/Stone1971/#Baroclinic-instability","page":"-","title":"Baroclinic instability","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu \n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b \n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"DDt equiv partialpartial t + U (partialpartial x)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"is the material derivative, mathbfu equiv (u v epsilon w) is the velocity perturbation, epsilon=HR is the aspect ratio, p is the pressure perturbation, and b is the buoyancy perturbation. The operator ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracDDtnabla^2 w \n    + frac1epsilon^2 fracpartial zetapartial z \n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta \n\n    fracDbDt\n    + v fracpartial Bpartial y + \n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.  The horizontal velocities u and v are related to the vertical velocity w and vertical vorticity zeta by the identities, ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    nabla_h^2 u = -fracpartial zetapartial y - fracpartial^2 wpartial x partial z \n\n    nabla_h^2 v = fracpartial zetapartial x - fracpartial^2 wpartial y partial z    \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"In deriving the above equations, we make use of the continuity equation and the definition of vertical vorticity zeta.","category":"page"},{"location":"modules/Stone1971/#Normal-mode","page":"-","title":"Normal mode","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Next we consider normal-mode perturbation solutions in the form of ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew  tildezeta  tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where the symbol mathfrakR denotes the real part and a variable with tilde' denotes an eigenfunction. The variable\\sigma=\\sigma_r + i \\sigma_i`. The real part represents the growth rate, and the imaginary part  shows the frequency of the  perturbation. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev + \n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 +\n(1epsilon^2)partial_z^2 - k^2big)^2  textand  mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n   \n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e., ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    tildew = partial_zz tildew = \n    partial_z tildezeta = partial_z tildeb = 0 \n     textat  z=0 1\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    mathsfitA mathsfX= sigma mathsfitB mathsfX   \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where sigma is the eigenvalue, mathsfX=tildew tildezeta tildeb^T is the eigenvector and the matrices mathsfitA, mathsfitB are the complex and real non-symmetric matrices, respectively. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"(Image: Alt text)","category":"page"},{"location":"literated/rRBC/#Finding-critical-Rayleigh-number-for-rotating-Rayleigh-Benard-Convection","page":"rRBC","title":"Finding critical Rayleigh number for rotating Rayleigh-Benard Convection","text":"","category":"section"},{"location":"literated/rRBC/#Introduction","page":"rRBC","title":"Introduction","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"This code finds critical Rayleigh number for the onset of convection for rotating Rayleigh Benrad Convection (rRBC) where the domain is periodic in y-direction. The code is benchmarked against Chandrashekar's theoretical results. Hydrodynamic and hydromagnetic stability by S. Chandrasekhar, 1961 (page no-95).","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Parameter:","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Ekman number E = 10‚Å¥","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Eigenvalue: critical modified Rayleigh number Ra_c = 1897","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"In this module, we do a linear stability analysis of a 2D rotating Rayleigh-Bernard case where the domain is periodic in the y-direction, in the x-direction is of infinite extent and vertically bounded.","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The background temperature profile overlinetheta is given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"overlinetheta = 1 - z","category":"page"},{"location":"literated/rRBC/#Governing-equations","page":"rRBC","title":"Governing equations","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The non-dimensional form of the equations governing the perturbation is given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    fracEPr fracpartial mathbfupartial t\n    + hatz times mathbfu =\n    -nabla p + Ra theta hatz + E nabla^2 mathbfu","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    fracpartial thetapartial t\n    = mathbfu cdot hatz + nabla^2 theta","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"    nabla cdot mathbfu = 0","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where E=nu(fH^2) is the Ekman number and Ra = galpha Delta T(f kappa), Delta T is the temperature difference between the bottom and the top walls) is the modified Rayleigh number. By applying the operators (nabla times nabla times) and (nabla times) and taking the z-component of the equations and assuming wave-like perturbations, we obtained the equations for vertical velocity w, vertical vorticity zeta and temperature theta,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    E mathcalD^4 w - partial_z zeta = -Ra mathcalD_h^2 theta\n\n    E mathcalD^2 zeta + partial_z w = 0\n\n    mathcalD^2 b + w = 0\nendalign","category":"page"},{"location":"literated/rRBC/#Normal-mode-solutions","page":"rRBC","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"Next we consider normal-mode perturbation solutions in the form of (we seek stationary solutions at the marginal state, i.e., sigma = 0),","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n w zeta theta(xyzt) = mathfrakRbig(tildew tildezeta tildetheta(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    E mathcalD^4  tildew - partial_z tildezeta = - Ra mathcalD_h^2 tildetheta\n\n    E mathcalD^2 tildezeta + partial_z tildew = 0\n\n    mathcalD^2 tildetheta + tildew = 0\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\nmathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + partial_z^2 - k^2big)^2\n textand  mathcalD_h^2 = (partial_y^2 - k^2)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n\n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"literated/rRBC/#Boundary-conditions","page":"rRBC","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    tildew = partial_zz tildew =\n    partial_z tildezeta = partial_z tildeb = 0\n     textat  z=0 1\nendalign","category":"page"},{"location":"literated/rRBC/#Generalized-eigenvalue-problem","page":"rRBC","title":"Generalized eigenvalue problem","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n AX= ŒªBX\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where lambda=Ra is the eigenvalue, and X is the eigenvector, The matrices A and B are given by","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"beginalign\n    A = beginbmatrix\n        E mathcalD^4  -mathcalD_z  0 \n        mathcalD_z  E mathcalD^2  0 \n        I  0  mathcalD^2\n    endbmatrix\n\n    B = beginbmatrix\n        0  0  -mathcalD_h^2 \n        0  0  0 \n        0  0  0\n    endbmatrix\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"where I is the identity matrix.","category":"page"},{"location":"literated/rRBC/#Load-required-packages","page":"rRBC","title":"Load required packages","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\n\nusing JLD2\nusing Parameters: @with_kw\n\nusing BiGSTARS\nusing BiGSTARS: AbstractParams\nusing BiGSTARS: Problem, OperatorI, TwoDGrid","category":"page"},{"location":"literated/rRBC/#Parameters","page":"rRBC","title":"Parameters","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"@with_kw mutable struct Params{T} <: AbstractParams\n    L::T                = 2œÄ            # horizontal domain size\n    H::T                = 1.0           # vertical   domain size\n    E::T                = 1.0e-4        # inverse of Reynolds number\n    k::T                = 0.0           # x-wavenumber\n    Ny::Int64           = 120           # no. of y-grid points\n    Nz::Int64           = 30            # no. of Chebyshev points\n    w_bc::String        = \"rigid_lid\"   # boundary condition for vertical velocity\n    Œ∂_bc::String        = \"free_slip\"   # boundary condition for vertical vorticity\n    b_bc::String        = \"fixed\"        # boundary condition for temperature\n    eig_solver::String  = \"arnoldi\"      # eigenvalue solver\nend","category":"page"},{"location":"literated/rRBC/#Basic-state","page":"rRBC","title":"Basic state","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function basic_state(grid, params)\n\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # Define the basic state\n    B‚ÇÄ   = @. Z - params.H  # temperature\n    U‚ÇÄ   = @. 0.0 * Z       # velocity\n\n    # Calculate all the necessary derivatives\n    deriv = compute_derivatives(U‚ÇÄ, B‚ÇÄ, grid.y, grid.D·∂ª, grid.D¬≤·∂ª, :All)\n\n    bs = initialize_basic_state_from_fields(B‚ÇÄ, U‚ÇÄ)\n\n    initialize_basic_state!(\n            bs,\n            deriv.‚àÇ ∏B‚ÇÄ,  deriv.‚àÇ·∂ªB‚ÇÄ,\n            deriv.‚àÇ ∏U‚ÇÄ,  deriv.‚àÇ·∂ªU‚ÇÄ,\n            deriv.‚àÇ ∏ ∏U‚ÇÄ, deriv.‚àÇ·∂ª·∂ªU‚ÇÄ, deriv.‚àÇ ∏·∂ªU‚ÇÄ,\n            deriv.‚àÇ ∏ ∏B‚ÇÄ, deriv.‚àÇ·∂ª·∂ªB‚ÇÄ, deriv.‚àÇ ∏·∂ªB‚ÇÄ\n        )\n\n    return bs\nend","category":"page"},{"location":"literated/rRBC/#Constructing-Generalized-EVP","page":"rRBC","title":"Constructing Generalized EVP","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function generalized_EigValProb(prob, grid, params)\n\n    bs = basic_state(grid, params)\n\n    N  = params.Ny * params.Nz\n    I‚Å∞ = sparse(Matrix(1.0I, N, N))\n    s‚ÇÅ = size(I‚Å∞, 1);\n    s‚ÇÇ = size(I‚Å∞, 2);\n\n    # the horizontal Laplacian operator\n    ‚àá‚Çï¬≤ = SparseMatrixCSC(Zeros(N, N))\n    ‚àá‚Çï¬≤ = (1.0 * prob.D¬≤ ∏ - 1.0 * params.k^2 * I‚Å∞)\n\n    # inverse of the horizontal Laplacian operator\n    H = inverse_Lap_hor(‚àá‚Çï¬≤)\n\n    # Construct the 4th order derivative\n    D‚Å¥  = (1.0 * prob.D‚Å¥ ∏\n        + 1.0 * prob.D‚Å¥·∂ª·¥∞\n        + 1.0 * params.k^4 * I‚Å∞\n        - 2.0 * params.k^2 * prob.D¬≤ ∏\n        - 2.0 * params.k^2 * prob.D¬≤·∂ª·¥∞\n        + 2.0 * prob.D¬≤ ∏¬≤·∂ª·¥∞)\n\n    # Construct the 2nd order derivative\n    D¬≤  = (1.0 * prob.D¬≤·∂ª·¥∞  + 1.0 * ‚àá‚Çï¬≤)\n    D‚Çô¬≤ = (1.0  * prob.D¬≤·∂ª·¥∫ + 1.0 * ‚àá‚Çï¬≤)\n\n    # Construct the matrix `A`\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # 1) Now define your 3√ó3 block-rows in a NamedTuple of 3-tuples\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # Construct the matrix `A`\n    Ablocks = (\n        w = (  # w-equation: ED‚Å¥ -D·∂ª zero\n                sparse(params.E * D‚Å¥),\n                sparse(-prob.D·∂ª·¥∫),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ)\n        ),\n        Œ∂ = (  # Œ∂-equation: D·∂ª ED¬≤ zero\n                sparse(prob.D·∂ª·¥∞),\n                sparse(params.E * D‚Çô¬≤),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ)\n        ),\n        b = (  # b-equation: I zero D¬≤\n                sparse(I‚Å∞),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                sparse(D¬≤)\n        )\n    )\n\n    # Construct the matrix `B`\n    Bblocks = (\n        w = (  # w-equation: zero, zero -‚àá‚Çï¬≤\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                sparse(-‚àá‚Çï¬≤)\n        ),\n        Œ∂ = (  # Œ∂-equation: zero, zero, zero\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ)\n        ),\n        b = (  # b-equation: zero, zero, zero\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ),\n                spzeros(Float64, s‚ÇÅ, s‚ÇÇ)\n        )\n    )\n\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # 2) Assemble in beautiful line\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    gevp = GEVPMatrices(Ablocks, Bblocks)\n\n\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n    # 3) And now you have exactly:\n    #    gevp.A, gevp.B                    ‚Üí full sparse matrices\n    #    gevp.As.w, gevp.As.Œ∂, gevp.As.b   ‚Üí each block-row view\n    #    gevp.Bs.w, gevp.Bs.Œ∂, gevp.Bs.b\n    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n    return gevp.A, gevp.B\nend","category":"page"},{"location":"literated/rRBC/#Eigenvalue-solver","page":"rRBC","title":"Eigenvalue solver","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function EigSolver(prob, grid, params, œÉ‚ÇÄ)\n\n    A, B = generalized_EigValProb(prob, grid, params)\n\n    if params.eig_solver == \"arpack\"\n\n        Œª, Œß = solve_shift_invert_arpack(A, B;\n                                        œÉ‚ÇÄ=œÉ‚ÇÄ,\n                                        which=:LM,\n                                        sortby=:R,\n                                        nev = 10,\n                                        maxiter=100)\n\n    elseif params.eig_solver == \"krylov\"\n\n        Œª, Œß = solve_shift_invert_krylov(A, B;\n                                        œÉ‚ÇÄ=œÉ‚ÇÄ,\n                                        which=:LM,\n                                        sortby=:R,\n                                        maxiter=100)\n\n    elseif params.eig_solver == \"arnoldi\"\n\n        Œª, Œß = solve_shift_invert_arnoldi(A, B;\n                                        œÉ‚ÇÄ=œÉ‚ÇÄ,\n                                        which=:LM,\n                                        sortby=:R,\n                                        nev = 10,\n                                        maxiter=100)\n    end\n    # ======================================================================\n    @assert length(Œª) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||AŒß - ŒªBŒß||‚ÇÇ: %f \\n\" norm(A * Œß[:,1] - Œª[1] * B * Œß[:,1])\n\n    # looking for min Ra\n    Œª, Œß = remove_evals(Œª, Œß, 10.0, 1.0e15, \"R\")\n    Œª, Œß = sort_evals_(Œª, Œß,  :R, rev=false)\n\n    print_evals(complex.(Œª))\n\n    return Œª[1], Œß[:,1]\nend","category":"page"},{"location":"literated/rRBC/#Solving-the-problem","page":"rRBC","title":"Solving the problem","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"function solve_rRBC(k::Float64)\n\n    # Calling problem parameters\n    params = Params{Float64}()\n\n    # Construct grid and derivative operators\n    grid  = TwoDGrid(params)\n\n    # Construct the necesary operator\n    ops  = OperatorI(params)\n    prob = Problem(grid, ops)\n\n    # update the wavenumber\n    #params = Params(p; k = k)\n    params.k = k\n\n    # initial guess for the growth rate\n    œÉ‚ÇÄ   = 0.0\n\n    Œª, Œß = EigSolver(prob, grid, params, œÉ‚ÇÄ)\n\n    # Theoretical results from Chandrashekar (1961)\n    Œª‚Çú = 189.7\n    @printf \"Analytical solution of critical Ra: %1.4e \\n\" Œª‚Çú\n\n    return abs(real(Œª) - Œª‚Çú)/Œª‚Çú < 1e-4\nend","category":"page"},{"location":"literated/rRBC/#Result","page":"rRBC","title":"Result","text":"","category":"section"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"solve_rRBC(0.0) # Critical Rayleigh number is at k=0.0","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"(attempt  1) trying œÉ = 0.000000\nConverged: first Œª = 193.728581 + i 0.000000 (œÉ = 0.000000)\n(attempt  2) trying œÉ = 0.000000\nConverged: first Œª = 193.728586 + i 0.000000 (œÉ = 0.000000)\nSuccessive eigenvalues converged: |ŒîŒª| = 4.81e-06 < 1.00e-05\n||AŒß - ŒªBŒß||‚ÇÇ: 0.014191 \nTop 9 eigenvalues (sorted):\nIdx ‚îÇ Real Part     Imag Part\n‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n  9 ‚îÇ  1.937286e+02          \n  8 ‚îÇ  1.933564e+02          \n  7 ‚îÇ  1.933564e+02          \n  6 ‚îÇ  1.907175e+02          \n  5 ‚îÇ  1.907175e+02          \n  4 ‚îÇ  1.906031e+02          \n  3 ‚îÇ  1.906031e+02          \n  2 ‚îÇ  1.897041e+02          \n  1 ‚îÇ  1.897041e+02          \nAnalytical solution of critical Ra: 1.8970e+02 \n","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"","category":"page"},{"location":"literated/rRBC/","page":"rRBC","title":"rRBC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#BiGSTARS.jl-Documentation","page":"Home","title":"BiGSTARS.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BiGSTARS.jl ‚Äî a Julia toolkit for bi-global linear-stability analysis of geophysical flows, built on a Chebyshev‚ÄìFourier spectral-collocation method.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The examples illustrate the key features of every module.   Browse the collection to see BiGSTARS.jl in action!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stone1971 example\nrRBC example","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"You can install the latest version of BiGSTARS.jl using Julia‚Äôs built-in package manager.  Just press ] in the Julia REPL to enter package mode, then add the package and run instantiate  to build all required dependencies.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"julia> ]\n(v1.11) pkg> add BiGSTARS\n(v1.11) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"We recommend installing BiGSTARS.jl using Julia‚Äôs built-in package manager, as this installs a stable, tagged release.  Later on, you can update BiGSTARS.jl to the latest tagged version again by using the package manager:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"(v1.11) pkg> update BiGSTARS","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"Note: Some releases may introduce breaking changes to certain modules.   If something stops working or your code behaves unexpectedly after an update, feel free to open an issue.   We're more than happy to help you get your model up and running again.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"warn: Julia 1.6 or newer required; Julia 1.10 or newer strongly encouraged\nThe latest version of BiGSTARS.jl requires at least Julia v1.6 to run.   Installing BiGSTARS.jl with an older version of Julia will instead install the latest version that is compatible with your Julia installation.BiGSTARS.jl is continuously tested on Julia v1.10 (the current long-term release) and v1.11.   We strongly recommend using one of these tested Julia versions.","category":"page"}]
}
