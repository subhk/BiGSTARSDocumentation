var documenterSearchIndex = {"docs":
[{"location":"literated/rRBC 2/#Finding-critical-Rayleigh-number-for-rotating-Rayleigh-Benard-Convection","page":"-","title":"Finding critical Rayleigh number for rotating Rayleigh-Benard Convection","text":"","category":"section"},{"location":"literated/rRBC 2/#Introduction","page":"-","title":"Introduction","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"This code finds critical Rayleigh number for the onset of convection for rotating Rayleigh Benrad Convection (rRBC) where the domain is periodic in y-direction. The code is benchmarked against Chandrashekar's theoretical results. Hydrodynamic and hydromagnetic stability by S. Chandrasekhar, 1961 (page no-95).","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"Parameter:","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"Ekman number E = 10⁴","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"Eigenvalue: critical modified Rayleigh number Ra_c = 1897","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"In this module, we do a linear stability analysis of a 2D rotating Rayleigh-Bernard case where the domain is periodic in the y-direction, in the x-direction is of infinite extent and vertically bounded.","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"The background temperature profile overlinetheta is given by","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"overlinetheta = 1 - z","category":"page"},{"location":"literated/rRBC 2/#Governing-equations","page":"-","title":"Governing equations","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"The non-dimensional form of the equations governing the perturbation is given by","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n    fracEPr fracpartial mathbfupartial t\n    + hatz times mathbfu =\n    -nabla p + Ra theta hatz + E nabla^2 mathbfu\n\n    fracpartial thetapartial t\n    = mathbfu cdot hatz + nabla^2 theta\n\n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"where E=nu(fH^2) is the Ekman number and Ra = galpha Delta T(f kappa), Delta T is the temperature difference between the bottom and the top walls) is the modified Rayleigh number. By applying the operators (nabla times nabla times) and (nabla times) and taking the z-component of the equations and assuming wave-like perturbations, we obtained the equations for vertical velocity w, vertical vorticity zeta and temperature theta,","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n    E mathcalD^4 w - partial_z zeta = -Ra mathcalD_h^2 theta\n\n    E mathcalD^2 zeta + partial_z w = 0\n\n    mathcalD^2 theta + w = 0\nendalign","category":"page"},{"location":"literated/rRBC 2/#Normal-mode-solutions","page":"-","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"Next we consider normal-mode perturbation solutions in the form of (we seek stationary solutions at the marginal state, i.e., sigma = 0),","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n w zeta theta(xyzt) = mathfrakRbig(tildew tildezeta tildetheta(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n    E mathcalD^4  tildew - partial_z tildezeta = - Ra mathcalD_h^2 tildetheta\n\n    E mathcalD^2 tildezeta + partial_z tildew = 0\n\n    mathcalD^2 tildetheta + tildew = 0\nendalign","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"where","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\nmathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + partial_z^2 - k^2big)^2\n textand  mathcalD_h^2 = (partial_y^2 - k^2)\nendalign","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n\n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"literated/rRBC 2/#Boundary-conditions","page":"-","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n    tildew = partial_zz tildew =\n    partial_z tildezeta = tildetheta = 0\n     textat  z=0 1\nendalign","category":"page"},{"location":"literated/rRBC 2/#Generalized-eigenvalue-problem-(GEVP)","page":"-","title":"Generalized eigenvalue problem (GEVP)","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n AX= λBX\nendalign","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"where lambda=Ra is the eigenvalue, and X=w zeta theta^T is the eigenvector. The matrices A and B are given by","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n    A = beginbmatrix\n        E mathcalD^4  -mathcalD_z  0 \n        mathcalD_z  E mathcalD^2  0 \n        1  0  mathcalD^2\n    endbmatrix\n\n    B = beginbmatrix\n        0  0  -mathcalD_h^2 \n        0  0  0 \n        0  0  0\n    endbmatrix\nendalign","category":"page"},{"location":"literated/rRBC 2/#Numerical-Implementation","page":"-","title":"Numerical Implementation","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"To implement the above GEVP in a numerical code, we need to actually write following sets of equations:","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"beginalign\n    A = beginbmatrix\n        E D^4  -D_z^D  0 \n        mathcalD^zD  E D^2N  0 \n        I  0  mathcalD^2D\n    endbmatrix\n\n    B = beginbmatrix\n        0  0  -mathcalD^2D \n        0  0  0 \n        0  0  0\n    endbmatrix\nendalign","category":"page"},{"location":"literated/rRBC 2/#Load-required-packages","page":"-","title":"Load required packages","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\nusing JLD2\nusing Parameters: @with_kw\nusing BiGSTARS\nusing BiGSTARS: AbstractParams\nusing BiGSTARS: Problem, OperatorI, TwoDGrid","category":"page"},{"location":"literated/rRBC 2/#Parameters","page":"-","title":"Parameters","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"@with_kw mutable struct Params{T} <: AbstractParams\n    L::T                = 2π            # horizontal domain size\n    H::T                = 1.0           # vertical   domain size\n    E::T                = 1.0e-4        # inverse of Reynolds number\n    k::T                = 0.0           # x-wavenumber\n    Ny::Int64           = 120           # no. of y-grid points\n    Nz::Int64           = 30            # no. of Chebyshev points\n    w_bc::String        = \"rigid_lid\"   # boundary condition for vertical velocity\n    ζ_bc::String        = \"free_slip\"   # boundary condition for vertical vorticity\n    b_bc::String        = \"fixed\"        # boundary condition for temperature\n    eig_solver::String  = \"arnoldi\"      # eigenvalue solver\nend","category":"page"},{"location":"literated/rRBC 2/#Basic-state","page":"-","title":"Basic state","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"function basic_state(grid, params)\n\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # Define the basic state\n    B₀   = @. Z - params.H  # temperature\n    U₀   = @. 0.0 * Z       # velocity\n\n    # Calculate all the necessary derivatives\n    deriv = compute_derivatives(U₀, B₀, grid.y, grid.Dᶻ, grid.D²ᶻ, :All)\n\n    bs = initialize_basic_state_from_fields(B₀, U₀)\n\n    initialize_basic_state!(\n            bs,\n            deriv.∂ʸB₀,  deriv.∂ᶻB₀,\n            deriv.∂ʸU₀,  deriv.∂ᶻU₀,\n            deriv.∂ʸʸU₀, deriv.∂ᶻᶻU₀, deriv.∂ʸᶻU₀,\n            deriv.∂ʸʸB₀, deriv.∂ᶻᶻB₀, deriv.∂ʸᶻB₀\n        )\n\n    return bs\nend","category":"page"},{"location":"literated/rRBC 2/#Constructing-Generalized-EVP","page":"-","title":"Constructing Generalized EVP","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"function generalized_EigValProb(prob, grid, params)\n\n    bs = basic_state(grid, params)\n\n    N  = params.Ny * params.Nz\n    I⁰ = sparse(Matrix(1.0I, N, N)) # Identity matrix\n    s₁ = size(I⁰, 1);\n    s₂ = size(I⁰, 2);\n\n    # the horizontal Laplacian operator: ∇ₕ² = ∂ʸʸ - k²\n    ∇ₕ² = SparseMatrixCSC(Zeros(N, N))\n    ∇ₕ² = (1.0 * prob.D²ʸ - 1.0 * params.k^2 * I⁰)\n\n    # inverse of the horizontal Laplacian operator\n    H = inverse_Lap_hor(∇ₕ²)\n\n    # Construct the 4th order derivative\n    D⁴  = (1.0 * prob.D⁴ʸ\n        + 1.0 * prob.D⁴ᶻᴰ\n        + 1.0 * params.k^4 * I⁰\n        - 2.0 * params.k^2 * prob.D²ʸ\n        - 2.0 * params.k^2 * prob.D²ᶻᴰ\n        + 2.0 * prob.D²ʸ²ᶻᴰ)\n\n    # Construct the 2nd order derivative\n    D²ᴰ = (1.0 * prob.D²ᶻᴰ  + 1.0 * ∇ₕ²)  # with Dirchilet BC\n    D²ᴺ = (1.0 * prob.D²ᶻᴺ  + 1.0 * ∇ₕ²)  # with Neumann BC\n\n    # Construct the matrix `A`\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 1) Now define your 3×3 block-rows in a NamedTuple of 3-tuples\n    # ──────────────────────────────────────────────────────────────────────────────\n    # Construct the matrix `A`\n    Ablocks = (\n        w = (  # w-equation: ED⁴ -Dᶻ zero\n                sparse(params.E * D⁴),\n                sparse(-prob.Dᶻᴺ),\n                spzeros(Float64, s₁, s₂)\n        ),\n        ζ = (  # ζ-equation: Dᶻ ED² zero\n                sparse(prob.Dᶻᴰ),\n                sparse(params.E * D²ᴺ),\n                spzeros(Float64, s₁, s₂)\n        ),\n        θ = (  # b-equation: I zero D²\n                sparse(I⁰),\n                spzeros(Float64, s₁, s₂),\n                sparse(D²ᴰ)\n        )\n    )\n\n    # Construct the matrix `B`\n    Bblocks = (\n        w = (  # w-equation: zero, zero -∇ₕ²\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂),\n                sparse(-∇ₕ²)\n        ),\n        ζ = (  # ζ-equation: zero, zero, zero\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂)\n        ),\n        θ = (  # b-equation: zero, zero, zero\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂)\n        )\n    )\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 2) Assemble in beautiful line\n    # ──────────────────────────────────────────────────────────────────────────────\n    gevp = GEVPMatrices(Ablocks, Bblocks)\n\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 3) And now you have exactly:\n    #    gevp.A, gevp.B                    → full sparse matrices\n    #    gevp.As.w, gevp.As.ζ, gevp.As.b   → each block-row view\n    #    gevp.Bs.w, gevp.Bs.ζ, gevp.Bs.b\n    # ──────────────────────────────────────────────────────────────────────────────\n\n    return gevp.A, gevp.B\nend","category":"page"},{"location":"literated/rRBC 2/#Eigenvalue-solver","page":"-","title":"Eigenvalue solver","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"function EigSolver(prob, grid, params, σ₀)\n\n    A, B = generalized_EigValProb(prob, grid, params)\n\n    if params.eig_solver == \"arpack\"\n\n        λ, Χ = solve_shift_invert_arpack(A, B;\n                                        σ₀=σ₀,\n                                        which=:LM,\n                                        sortby=:R,\n                                        nev = 10,\n                                        maxiter=100)\n\n    elseif params.eig_solver == \"krylov\"\n\n        λ, Χ = solve_shift_invert_krylov(A, B;\n                                        σ₀=σ₀,\n                                        which=:LM,\n                                        sortby=:R,\n                                        maxiter=100)\n\n    elseif params.eig_solver == \"arnoldi\"\n\n        λ, Χ = solve_shift_invert_arnoldi(A, B;\n                                        σ₀=σ₀,\n                                        which=:LM,\n                                        sortby=:R,\n                                        nev = 10,\n                                        maxiter=100)\n    end\n    # ======================================================================\n    @assert length(λ) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"||AΧ - λBΧ||₂: %f \\n\" norm(A * Χ[:,1] - λ[1] * B * Χ[:,1])\n\n    # looking for min Ra\n    λ, Χ = remove_evals(λ, Χ, 10.0, 1.0e15, \"R\")\n    λ, Χ = sort_evals_(λ, Χ,  :R, rev=false)\n\n    print_evals(complex.(λ))\n\n    return λ[1], Χ[:,1]\nend","category":"page"},{"location":"literated/rRBC 2/#Solving-the-problem","page":"-","title":"Solving the problem","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"function solve_rRBC(k::Float64)\n\n    # Calling problem parameters\n    params = Params{Float64}()\n\n    # Construct grid and derivative operators\n    grid  = TwoDGrid(params)\n\n    # Construct the necesary operator\n    ops  = OperatorI(params)\n    prob = Problem(grid, ops)\n\n    # update the wavenumber\n    #params = Params(p; k = k)\n    params.k = k\n\n    # initial guess for the growth rate\n    σ₀   = 0.0\n\n    λ, Χ = EigSolver(prob, grid, params, σ₀)\n\n    # Theoretical results from Chandrashekar (1961)\n    λₜ = 189.7\n    @printf \"Analytical solution of critical Ra: %1.4e \\n\" λₜ\n\n    return abs(real(λ) - λₜ)/λₜ < 1e-4\nend","category":"page"},{"location":"literated/rRBC 2/#Result","page":"-","title":"Result","text":"","category":"section"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"solve_rRBC(0.0) # Critical Rayleigh number is at k=0.0","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"(attempt  1) trying σ = 0.000000\nConverged: first λ = 193.728586 + i 0.000000 (σ = 0.000000)\n(attempt  2) trying σ = 0.000000\nConverged: first λ = 193.728586 + i 0.000000 (σ = 0.000000)\nSuccessive eigenvalues converged: |Δλ| = 1.83e-07 < 1.00e-05\n||AΧ - λBΧ||₂: 0.011119 \nTop 9 eigenvalues (sorted):\nIdx │ Real Part     Imag Part\n────┼──────────────────────────────\n  9 │  1.937286e+02          \n  8 │  1.933564e+02          \n  7 │  1.933563e+02          \n  6 │  1.907175e+02          \n  5 │  1.907172e+02          \n  4 │  1.906031e+02          \n  3 │  1.906031e+02          \n  2 │  1.897041e+02          \n  1 │  1.897041e+02          \nAnalytical solution of critical Ra: 1.8970e+02 \n","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"","category":"page"},{"location":"literated/rRBC 2/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributors'-Guide","page":"Contributor's Guide","title":"Contributors' Guide","text":"","category":"section"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"This is a short guide for potential BiGSTARS.jl contributors.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"We welcome contributions and questions! If you’d like to get involved, please don’t hesitate to  open an issue to start a discussion.","category":"page"},{"location":"contributing/","page":"Contributor's Guide","title":"Contributor's Guide","text":"Thank you for helping improve BiGSTARS.jl!","category":"page"},{"location":"installation_instructions/#Installation-instructions","page":"Installation instructions","title":"Installation instructions","text":"","category":"section"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"You can install the latest version of BiGSTARS.jl using Julia’s built-in package manager.  Just press ] in the Julia REPL to enter package mode, then add the package and run instantiate  to build all required dependencies.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"julia> ]\n(v1.11) pkg> add BiGSTARS\n(v1.11) pkg> instantiate","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"We recommend installing BiGSTARS.jl using Julia’s built-in package manager, as this installs a stable, tagged release.  Later on, you can update BiGSTARS.jl to the latest tagged version again by using the package manager:","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"(v1.11) pkg> update BiGSTARS","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"Note: Some releases may introduce breaking changes to certain modules.   If something stops working or your code behaves unexpectedly after an update, feel free to open an issue.   We're more than happy to help you get your model up and running again.","category":"page"},{"location":"installation_instructions/","page":"Installation instructions","title":"Installation instructions","text":"warn: Julia 1.6 or newer required; Julia 1.10 or newer strongly encouraged\nThe latest version of BiGSTARS.jl requires at least Julia v1.6 to run.   Installing BiGSTARS.jl with an older version of Julia will instead install the latest version that is compatible with your Julia installation.BiGSTARS.jl is continuously tested on Julia v1.10 (the current long-term release) and v1.11.   We strongly recommend using one of these tested Julia versions.","category":"page"},{"location":"modules/BiGSTARS/","page":"…other functions…","title":"…other functions…","text":"```@autodocs Modules = [BiGSTARS] Order = [   FourierDiff,   FourierDifffdm,   chebdif,   chebcoordtransform,   chebcoordtransformho,","category":"page"},{"location":"modules/BiGSTARS/#…other-functions…","page":"…other functions…","title":"…other functions…","text":"","category":"section"},{"location":"modules/BiGSTARS/","page":"…other functions…","title":"…other functions…","text":"]","category":"page"},{"location":"modules/Stone1971/#Baroclinic-instability","page":"-","title":"Baroclinic instability","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu \n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b \n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"DDt equiv partialpartial t + U (partialpartial x)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"is the material derivative, mathbfu equiv (u v epsilon w) is the velocity perturbation, epsilon=HR is the aspect ratio, p is the pressure perturbation, and b is the buoyancy perturbation. The operator ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    fracDDtnabla^2 w \n    + frac1epsilon^2 fracpartial zetapartial z \n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta \n\n    fracDbDt\n    + v fracpartial Bpartial y + \n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.  The horizontal velocities u and v are related to the vertical velocity w and vertical vorticity zeta by the identities, ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    nabla_h^2 u = -fracpartial zetapartial y - fracpartial^2 wpartial x partial z \n\n    nabla_h^2 v = fracpartial zetapartial x - fracpartial^2 wpartial y partial z    \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"In deriving the above equations, we make use of the continuity equation and the definition of vertical vorticity zeta.","category":"page"},{"location":"modules/Stone1971/#Normal-mode","page":"-","title":"Normal mode","text":"","category":"section"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Next we consider normal-mode perturbation solutions in the form of ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew  tildezeta  tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where the symbol mathfrakR denotes the real part and a variable with tilde' denotes an eigenfunction. The variable\\sigma=\\sigma_r + i \\sigma_i`. The real part represents the growth rate, and the imaginary part  shows the frequency of the  perturbation. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev + \n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 +\n(1epsilon^2)partial_z^2 - k^2big)^2  textand  mathcalD_h^2 = (partial_y^2 - k^2)","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n   \n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e., ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    tildew = partial_zz tildew = \n    partial_z tildezeta = partial_z tildeb = 0 \n     textat  z=0 1\nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"beginalign\n    mathsfitA mathsfX= sigma mathsfitB mathsfX   \nendalign","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"where sigma is the eigenvalue, mathsfX=tildew tildezeta tildeb^T is the eigenvector and the matrices mathsfitA, mathsfitB are the complex and real non-symmetric matrices, respectively. ","category":"page"},{"location":"modules/Stone1971/","page":"-","title":"-","text":"(Image: Alt text)","category":"page"},{"location":"literated/Eady/#Linear-stability-analysis-of-baroclinic-instability-of-a-2D-front-based-on-Eady-(1949)","page":"Eady","title":"Linear stability analysis of baroclinic instability of a 2D front based on Eady (1949)","text":"","category":"section"},{"location":"literated/Eady/#Introduction","page":"Eady","title":"Introduction","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"Eady (1949) showed that in a uniformly sheared, stratified layer between two rigid lids on an f-plane, two counter-propagating Rossby edge waves can phase lock and convert available potential energy into kinetic energy, producing baroclinic eddies that grow fastest at wavelengths about four deformation radii and on timescales of a few days.","category":"page"},{"location":"literated/Eady/#Basic-state","page":"Eady","title":"Basic state","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The basic state is given by","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    B(y z) = Ri z - y \n    U(y z) = z - 12\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where Ri is the Richardson number, and N^2 = Ri is the stratification.","category":"page"},{"location":"literated/Eady/#Governing-equations","page":"Eady","title":"Governing equations","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The non-dimensional form of the linearized version of the QG PV perturbation equation under the f-plane approximation can be expressed as,","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    fracpartial q^textqgpartial t + U fracpartial q^textqgpartial x + fracpartial psipartial x\n    fracpartial Q^textqgpartial y = E  nabla_h^2 q^textqg\n  textfor  0  z 1\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where q^textqg is the perturbation QG PV, and it is defined as","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    q^textqg = nabla_h^2 psi^textqg +\n    fracpartialpartial z\n    left(frac1N^2 fracpartial psi^textqgpartial zright)\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The variable psi^textqg describes the QG perturbation streamfunction with u^textqg=-partial_y psi^textqg and v^textqg=partial_x psi^textqg. The variable Q^textqg describes the QG PV of the basic state, which is defined as \\citep{pedlosky2013geophysical}","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    Q^textqg = -fracpartial Upartial y + fracpartialpartial zleft(fracBN^2 right)\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"and the cross-front gradient of Q^textqg is defined as","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    fracpartial Q^textqgpartial y = - fracpartialpartial zleft(fracpartial_z UN^2 right)\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The linearized perturbation buoyancy equation at the top and the bottom boundary is","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    fracpartial b^textqgpartial t + U fracpartial b^textqgpartial x\n      + fracpartial psi^textqgpartial x\n    fracpartial Bpartial y = 0\n     textat  z=0  textand  1\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where b^textqg=partial_z psi^textqg.","category":"page"},{"location":"literated/Eady/#Normal-mode-solutions","page":"Eady","title":"Normal-mode solutions","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"Next, we seek normal-mode solutions for psi^textqg and q^textqg in the form of","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    psi^textqg q^textqg = mathfrakRbig(widetildepsi^textqg\n  widetildeq^textqg big)(y z) e^i kx-sigma t\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where widetildepsi^textqg, widetildeq^textqg are the eigenfunctions of psi^textqg and q^textqg, respectively. In terms of streamfunction psi^textqg,","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    (sigma + i k U) - E mathscrLwidetildepsi^textqg\n  + i k partial_y Q^textqg widetildepsi^textqg = 0   textfor  0  z 1\n\n    (sigma + i k U_-)partial_z widetildepsi^textqg_-\n  + i k partial_y B_- widetildepsi^textqg_- = 0  textat  z = 0\n\n    (sigma + i k U_+)partial_z widetildepsi^textqg_+\n  + i k partial_y B_+ widetildepsi^textqg_+ = 0  textat  z = 1\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where mathscrL is a linear operator, and is defined as mathscrL equiv mathcalD_h^2 + 1N^2 partial_z^2, where mathcalD_h^2 = (partial_y^2 - k^2). The subscripts -+ denote the values of the fields at z=0 and z=1, respectively.","category":"page"},{"location":"literated/Eady/#Generalized-eigenvalue-problem","page":"Eady","title":"Generalized eigenvalue problem","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"The above set of equations can be cast into a generalized eigenvalue problem","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n AX= λBX\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where lambda is the eigenvalue, and X is the eigenvector. The matrices A and B are given by","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"beginalign\n    A = beginbmatrix\n        ik U mathcalD_0^2\n       + ik partial_y Q\n      - E mathcalD_h^2 mathcalD_0^2\n  endbmatrix\n  \n    B = beginbmatrix\n      - mathcalD_0^2\n    endbmatrix\nendalign","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"where D_0^2 = mathcalD_h^2 + (1N^2) mathcalD_z^2.","category":"page"},{"location":"literated/Eady/#Load-required-packages","page":"Eady","title":"Load required packages","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\nusing JLD2\nusing Parameters: @with_kw\n\nusing BiGSTARS\nusing BiGSTARS: AbstractParams\nusing BiGSTARS: Problem, OperatorI, TwoDGrid","category":"page"},{"location":"literated/Eady/#Parameters","page":"Eady","title":"Parameters","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"@with_kw mutable struct Params{T} <: AbstractParams\n    L::T                = 1.0           # horizontal domain size\n    H::T                = 1.0           # vertical domain size\n    Ri::T               = 1.0           # the Richardson number\n    k::T                = 0.1           # along-front wavenumber\n    E::T                = 1.0e-12        # the Ekman number\n    Ny::Int64           = 60            # no. of y-grid points\n    Nz::Int64           = 30            # no. of z-grid points (should be different from Ny)\n    eig_solver::String  = \"arpack\"      # eigenvalue solver\nend","category":"page"},{"location":"literated/Eady/#Basic-state-2","page":"Eady","title":"Basic state","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"function basic_state(grid, params)\n\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # Define the basic state\n    B₀   = @. 1.0 * params.Ri * Z - Y    # buoyancy\n    U₀   = @. 1.0 * Z - 0.5 * params.H   # along-front velocity\n\n    # Calculate all the necessary derivatives\n    deriv = compute_derivatives(U₀, B₀, grid.y, grid.Dᶻ, grid.D²ᶻ, :All)\n\n    bs = initialize_basic_state_from_fields(B₀, U₀)\n\n    initialize_basic_state!(\n            bs,\n            deriv.∂ʸB₀,  deriv.∂ᶻB₀,\n            deriv.∂ʸU₀,  deriv.∂ᶻU₀,\n            deriv.∂ʸʸU₀, deriv.∂ᶻᶻU₀, deriv.∂ʸᶻU₀,\n            deriv.∂ʸʸB₀, deriv.∂ᶻᶻB₀, deriv.∂ʸᶻB₀\n        )\n\n    return bs, deriv\nend","category":"page"},{"location":"literated/Eady/#Constructing-Generalized-EVP","page":"Eady","title":"Constructing Generalized EVP","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"function generalized_EigValProb(prob, grid, params)\n\n    bs, deriv = basic_state(grid, params)\n\n    N  = params.Ny * params.Nz\n    I⁰ = sparse(Matrix(1.0I, N, N))  # Identity matrix\n    s₁ = size(I⁰, 1);\n    s₂ = size(I⁰, 2);\n\n    # the horizontal Laplacian operator:  ∇ₕ² = ∂ʸʸ - k²\n    ∇ₕ² = SparseMatrixCSC(Zeros(N, N))\n    ∇ₕ² = (1.0 * prob.D²ʸ - 1.0 * params.k^2 * I⁰)\n\n    # some quantities required later\n    bs_∂ᶻB₀⁻¹  = @. 1.0/deriv.∂ᶻB₀\n    bs_∂ᶻB₀⁻²  = @. 1.0/(deriv.∂ᶻB₀ * deriv.∂ᶻB₀)\n\n    ∂ᶻB₀⁻¹::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n    ∂ᶻB₀⁻²::Array{Float64, 2} = SparseMatrixCSC(Zeros(N, N))\n    ∂ʸQ₀::Array{Float64, 2}   = SparseMatrixCSC(Zeros(N, N)) # PV gradient is zero\n\n    # converting to matrics\n    ∂ᶻB₀⁻¹[diagind(∂ᶻB₀⁻¹)] = bs_∂ᶻB₀⁻¹\n    ∂ᶻB₀⁻²[diagind(∂ᶻB₀⁻²)] = bs_∂ᶻB₀⁻²\n\n    # definition of perturbation PV, q = D₂³ᵈ{ψ}\n    D₂³ᵈ = (1.0 * ∇ₕ²\n            + 1.0  * ∂ᶻB₀⁻¹ * prob.D²ᶻ\n            - 1.0  * bs.fields.∂ᶻᶻB₀  * ∂ᶻB₀⁻² * prob.Dᶻ)\n\n    # Construct the matrix `A`\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 1) Now define your 1×1 block-rows in a NamedTuple of 1-tuples\n    # ──────────────────────────────────────────────────────────────────────────────\n    # Construct the matrix `A`\n    Ablocks = (\n        ψ = (  # ψ-equation\n                sparse(1.0im * params.k * bs.fields.U₀ * D₂³ᵈ\n                    + 1.0im * params.k * ∂ʸQ₀\n                    - 1.0 * params.E * ∇ₕ² * D₂³ᵈ\n                )\n        ),\n    )\n\n    # Construct the matrix `B`\n    Bblocks = (\n        ψ = (  # ψ-equation: [-D₂³ᵈ]\n                sparse(-D₂³ᵈ)\n        ),\n    )\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 2) Assemble the block-row matrices into a GEVPMatrices object\n    # ──────────────────────────────────────────────────────────────────────────────\n    gevp = GEVPMatrices(Ablocks, Bblocks)\n\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 3) And now you have exactly:\n    #    gevp.A, gevp.B                    → full sparse matrices\n    #    gevp.As.w, gevp.As.ζ, gevp.As.b   → each block-row view\n    #    gevp.Bs.w, gevp.Bs.ζ, gevp.Bs.b\n    # ──────────────────────────────────────────────────────────────────────────────\n\n    B = SparseMatrixCSC(Zeros{ComplexF64}(s₁, s₂))\n    C = SparseMatrixCSC(Zeros{ Float64  }(s₁, s₂))\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 4) Implementing boundary conditions\n    # ──────────────────────────────────────────────────────────────────────────────\n    _, zi = ndgrid(1:1:params.Ny, 1:1:params.Nz)\n    zi    = transpose(zi);\n    zi    = zi[:];\n    bcᶻ⁻  = findall( x -> (x==1),         zi )      ## @ z=0\n    bcᶻ⁺  = findall( x -> (x==params.Nz), zi )      ## @ z=1\n\n    # Implementing boundary condition for 𝓛 matrix in the z-direction:\n    B[:,1:1s₂] = 1.0im * params.k * bs.fields.U₀ * prob.Dᶻ - 1.0im * params.k * bs.fields.∂ᶻU₀\n\n    # Bottom boundary condition @ z=0\n    @. gevp.A[bcᶻ⁻, :] = B[bcᶻ⁻, :]\n\n    # Top boundary condition @ z = 1\n    @. gevp.A[bcᶻ⁺, :] = B[bcᶻ⁺, :]\n\n    # Implementing boundary condition for ℳ matrix in the z-direction:\n    C[:,1:1s₂] = -1.0 * prob.Dᶻ\n\n    # Bottom boundary condition @ z=0\n    @. gevp.B[bcᶻ⁻, :] = C[bcᶻ⁻, :]\n\n    # Top boundary condition @ z = 1\n    @. gevp.B[bcᶻ⁺, :] = C[bcᶻ⁺, :]\n\n    return gevp.A, gevp.B\nend","category":"page"},{"location":"literated/Eady/#Eigenvalue-solver","page":"Eady","title":"Eigenvalue solver","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"function EigSolver(prob, grid, params, σ₀)\n\n    A, B = generalized_EigValProb(prob, grid, params)\n\n    if params.eig_solver == \"arpack\"\n        λ, Χ = solve_shift_invert_arnoldi(A, B; σ₀=σ₀, which=:LR, sortby=:R)\n\n    elseif params.eig_solver == \"krylov\"\n\n        λ, Χ = solve_shift_invert_krylov(A, B; σ₀=σ₀, which=:LR, sortby=:R)\n\n    elseif params.eig_solver == \"arnoldi\"\n\n        λ, Χ = solve_shift_invert_arnoldi(A, B; σ₀=σ₀, which=:LR, sortby=:R)\n    end\n    # ======================================================================\n    @assert length(λ) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(λ[1]) imag(λ[1])\n\n    return λ[1], Χ[:,1]\nend","category":"page"},{"location":"literated/Eady/#Solving-the-Eady-problem","page":"Eady","title":"Solving the Eady problem","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"function solve_Eady(k::Float64)\n\n    # Calling problem parameters\n    params = Params{Float64}()\n\n    # Construct grid and derivative operators\n    grid  = TwoDGrid(params)\n\n    # Construct the necesary operator\n    ops  = OperatorI(params)\n    prob = Problem(grid, ops)\n\n    # update the wavenumber\n    params.k = k\n\n    # initial guess for the growth rate\n    σ₀   = 0.02\n\n    λ, Χ = EigSolver(prob, grid, params, σ₀)\n\n    # Analytical solution of Eady (1949) for the growth rate\n    μ  = 1.0 * params.k * √params.Ri\n    λₜ = 1.0/√params.Ri * √( (coth(0.5μ) - 0.5μ)*(0.5μ - tanh(0.5μ)) )\n\n    @printf \"Analytical solution of Stone (1971) for the growth rate: %f \\n\" λₜ\n\n    return abs(λ.re - λₜ) < 1e-3\nend","category":"page"},{"location":"literated/Eady/#Result","page":"Eady","title":"Result","text":"","category":"section"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"solve_Eady(0.1) # growth rate is at k=0.1","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"(attempt  1) trying σ = 0.024000\nConverged: first λ = 0.028829 + i -0.000000 (σ = 0.024000)\n(attempt  2) trying σ = 0.024800\nConverged: first λ = 0.028829 + i 0.000000 (σ = 0.024800)\nSuccessive eigenvalues converged: |Δλ| = 5.27e-13 < 1.00e-05\nlargest growth rate : 2.8829e-02+2.6344e-13im\nAnalytical solution of Stone (1971) for the growth rate: 0.028829 \n","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"","category":"page"},{"location":"literated/Eady/","page":"Eady","title":"Eady","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/Stone1971/#Linear-stability-analysis-of-baroclinic-instability-of-a-2D-front-based-on-Stone-(1971)","page":"Stone1971","title":"Linear stability analysis of baroclinic instability of a 2D front based on Stone (1971)","text":"","category":"section"},{"location":"literated/Stone1971/#Introduction","page":"Stone1971","title":"Introduction","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Baroclinic instability (BCI) arises when a rotating, stratified fluid has tilted density surfaces, enabling eddies to tap available potential energy and convert it to kinetic energy. Stone (1971) investigated non-hydrostatic effects on BCI using Eady’s framework. He found that as the Ri decreases, the wavelength of the most unstable mode increases while the growth rate diminishes relative to predictions from the quasigeostrophic (QG) approximation.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The basic state is given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    B(y z) = Ri z - y \n    U(y z) = z - 12\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where Ri is the Richardson number. We aim to analyze the stability of the above basic state against small perturbations. The perturbation variables are defined as","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    mathbfu(x y z t) = (u v epsilon w)(x y z t) \n    p(x y z t) = p(x y z t) \n    b(x y z t) = b(x y z t)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where epsilon is the aspect ratio, mathbfu is the velocity perturbation, p is the pressure perturbation, and b is the buoyancy perturbation.","category":"page"},{"location":"literated/Stone1971/#Governing-equations","page":"Stone1971","title":"Governing equations","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The resulting nondimensional, linearized Boussinesq equations of motion under the f-plane approximation are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracD mathbfuDt\n    + Big(v fracpartial Upartial y + w fracpartial Upartial z Big) hatx\n    + hatz times mathbfu =\n    -nabla p + frac1epsilon b hatz + E nabla^2 mathbfu\n\n    fracDbDt\n    +  v fracpartial Bpartial y + w fracpartial Bpartial z = fracEPr nabla^2 b\n\n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  DDt equiv partialpartial t + U (partialpartial x)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"is the material derivative. The operators:","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla equiv (partialpartial x partialpartial y (1epsilon) partialpartial z)","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"nabla^2 equiv partial^2partial x^2 + partial^2partial y^2 + (1epsilon^2) partial^2 partial z^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"To eliminate pressure, following [teed2010rapidly@citet, we apply the operator hatz cdot nabla times nabla times  and hatz cdot nabla times to the above momentum equation. This procedure yields governing equations of three perturbation variables, the vertical velocity w, the vertical vorticity zeta  (=hatz cdot nabla times mathbfu), and the buoyancy b","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    fracDDtnabla^2 w\n    + frac1epsilon^2 fracpartial zetapartial z\n    = frac1epsilon^2 nabla_h^2 b + E nabla^4 w\n\n    fracD zetaDt\n    - fracpartial Upartial zfracpartial wpartial y\n    - fracpartial wpartial z = E nabla^2 zeta\n\n    fracDbDt\n    + v fracpartial Bpartial y +\n    w fracpartial Bpartial z\n    = fracEPr nabla^2 b\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"  nabla_h^2 equiv partial^2 partial x^2 + partial^2partial y^2","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The benefit of using the above sets of equations is that it enables us to examine the instability at an along-front wavenumber k to 0.","category":"page"},{"location":"literated/Stone1971/#Normal-mode-solutions","page":"Stone1971","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Next we consider normal-mode perturbation solutions in the form of","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    w zeta b(xyzt) = mathfrakRbig(tildew tildezeta tildeb(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. The variable sigma=sigma_r + i sigma_i. The real part represents the growth rate, and the imaginary part shows the frequency of the  perturbation.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    (i k U - E mathcalD^2) mathcalD^2 tildew\n    + epsilon^-2 partial_z tildezeta\n    - epsilon^-2 mathcalD_h^2 tildeb = -sigma mathcalD^2 tildew\n\n    - partial_z U partial_y tildew\n    - partial_z tildew\n    + left(ik U - E mathcalD^2 right) tildezeta = -sigma tildezeta\n\n    partial_z B tildew + partial_y B  tildev +\n    leftik U - E mathcalD^2 right tildeb = -sigma tildeb\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n mathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + (1epsilon^2)partial_z^2 - k^2big)^2\n textand  mathcalD_h^2 = (partial_y^2 - k^2)\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n\n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"literated/Stone1971/#Boundary-conditions","page":"Stone1971","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n  tildew = partial_zz tildew =\n  partial_z tildezeta = partial_z tildeb = 0\n   textat  z=0 1\nendalign","category":"page"},{"location":"literated/Stone1971/#Generalized-eigenvalue-problem-(GEVP)","page":"Stone1971","title":"Generalized eigenvalue problem (GEVP)","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem (GEVP),","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n AX= λBX\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where lambda is the eigenvalue, and X is the eigenvector. The matrices A and B are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    A = beginbmatrix\n        epsilon^2(i k U mathcalD^2 -E mathcalD^4)\n          partial_z   -mathcalD_h^2\n  \n        -partial_z U partial_y - partial_z\n           i k U - E mathcalD^2  0\n \n      partial_z B -  partial_y B (mathcalD_h^1)^-1 partial_yz\n        k partial_y B (mathcalD_h^1)^-1   ikU - E mathcalD^2\n    endbmatrix\n\n    B = beginbmatrix\n        epsilon^2 mathcalD^2  0  0 \n        0  1  0 \n        0  0  1\n    endbmatrix\nendalign","category":"page"},{"location":"literated/Stone1971/#Numerical-Implementation","page":"Stone1971","title":"Numerical Implementation","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"To implement the above GEVP in a numerical code, we need to actually write following sets of equations:","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    A = beginbmatrix\n        epsilon^2(i k textdiagm(U) mathcalD^2D - E mathcalD^4D)\n        -D_z^D  0_n\n\n        -textdiagm(partial_z U) mathcalD^y  i k textdiagm(U) - E mathcalD^2N  0_n\n\n        textdiagm(partial_z B) - textdiagm(partial_y B) H mathcalD^yzD\n         k textdiagm(partial_y B) H  ik textdiagm(U) - E mathcalD^2N\n    endbmatrix\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where H is the inverse of the horizontal Laplacian operator (mathcalD_h^2)^-1, and textdiagm(phi) is a diagonal matrix with the elements of any vector phi on its diagonal.","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\n    B = beginbmatrix\n        epsilon^2 mathcalD^2D  0_n  0_n \n        0_n  I_n  0_n \n        0_n  0_n  I_n\n    endbmatrix\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where I_n is the identity matrix of size (n times n), where n=N_y N_z, N_y and N_z are the number of grid points in the y and z directions respectively. 0_n is the zero matrix of size (n times n). The differential operator matrices are given by","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"beginalign\nD^2D = mathcalD_y^2 otimes I_z + I_y otimes mathcalD_z^2D - k^2 I_n\n\nD^2N = mathcalD_y^2 otimes I_z + I_y otimes mathcalD_z^2N - k^2 I_n\n\n D^4D = mathcalD_y^4 otimes I_z\n   + I_y otimes mathcalD_z^4D + k^4 I_n - 2 k^2 D_y^2 otimes I_z\n   - 2 k^2 I_y otimes D_z^2D + 2 D_y^2 otimes D_z^2D\n\nH = (mathcalD_y^2 otimes I_z - k^2 I_n)^-1\nendalign","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"where otimes is the Kronecker product. I_y and I_z are identity matrices of size (N_y times N_y) and (N_z times N_z) respectively, and I=I_y otimes I_z. The superscripts D and N in the operator matrices denote the type of boundary conditions applied (D for Dirichlet or N for Neumann). mathcalD_y, mathcalD_y^2 and mathcalD_y^3 are the first, second and third order Fourier differentiation matrix of size of (N_y times N_y). mathcalD_z, mathcalD_z^2 and mathcalD_z^4 are the first, second and fourth order Chebyshev differentiation matrix of size of (N_z times N_z).","category":"page"},{"location":"literated/Stone1971/#Load-required-packages","page":"Stone1971","title":"Load required packages","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\nusing JLD2\nusing Parameters: @with_kw\n\nusing BiGSTARS\nusing BiGSTARS: AbstractParams\nusing BiGSTARS: Problem, OperatorI, TwoDGrid","category":"page"},{"location":"literated/Stone1971/#Parameters","page":"Stone1971","title":"Parameters","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"@with_kw mutable struct Params{T} <: AbstractParams\n    L::T                = 1.0           # horizontal domain size\n    H::T                = 1.0           # vertical domain size\n    Ri::T               = 1.0           # the Richardson number\n    ε::T                = 0.1           # aspect ratio ε ≡ H/L\n    k::T                = 0.1           # along-front wavenumber\n    E::T                = 1.0e-8        # the Ekman number\n    Ny::Int64           = 24            # no. of y-grid points\n    Nz::Int64           = 20            # no. of z-grid points\n    w_bc::String        = \"rigid_lid\"   # boundary condition for vertical velocity\n    ζ_bc::String        = \"free_slip\"   # boundary condition for vertical vorticity\n    b_bc::String        = \"zero_flux\"   # boundary condition for buoyancy\n    eig_solver::String  = \"arpack\"      # eigenvalue solver\nend","category":"page"},{"location":"literated/Stone1971/#Basic-state","page":"Stone1971","title":"Basic state","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function basic_state(grid, params)\n\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # Define the basic state\n    B₀   = @. 1.0 * params.Ri * Z - Y    # buoyancy\n    U₀   = @. 1.0 * Z - 0.5 * params.H   # along-front velocity\n\n    # Calculate all the necessary derivatives\n    deriv = compute_derivatives(U₀, B₀, grid.y, grid.Dᶻ, grid.D²ᶻ, :All)\n\n    bs = initialize_basic_state_from_fields(B₀, U₀)\n\n    initialize_basic_state!(\n            bs,\n            deriv.∂ʸB₀,  deriv.∂ᶻB₀,\n            deriv.∂ʸU₀,  deriv.∂ᶻU₀,\n            deriv.∂ʸʸU₀, deriv.∂ᶻᶻU₀, deriv.∂ʸᶻU₀,\n            deriv.∂ʸʸB₀, deriv.∂ᶻᶻB₀, deriv.∂ʸᶻB₀\n        )\n\n    return bs\nend","category":"page"},{"location":"literated/Stone1971/#Constructing-Generalized-EVP","page":"Stone1971","title":"Constructing Generalized EVP","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function generalized_EigValProb(prob, grid, params)\n\n    bs = basic_state(grid, params)\n\n    N  = params.Ny * params.Nz\n    I⁰ = sparse(Matrix(1.0I, N, N))  # Identity matrix\n    s₁ = size(I⁰, 1);\n    s₂ = size(I⁰, 2);\n\n    # the horizontal Laplacian operator:  ∇ₕ² = ∂ʸʸ - k²\n    ∇ₕ² = SparseMatrixCSC(Zeros(N, N))\n    ∇ₕ² = (1.0 * prob.D²ʸ - 1.0 * params.k^2 * I⁰)\n\n    # inverse of the horizontal Laplacian operator\n    H = inverse_Lap_hor(∇ₕ²)\n\n    # Construct the 4th order derivative\n    D⁴ᴰ = (1.0 * prob.D⁴ʸ\n        + 1.0/params.ε^4 * prob.D⁴ᶻᴰ\n        + 1.0 * params.k^4 * I⁰\n        - 2.0 * params.k^2 * prob.D²ʸ\n        - 2.0/params.ε^2 * params.k^2 * prob.D²ᶻᴰ\n        + 2.0/params.ε^2 * prob.D²ʸ²ᶻᴰ)\n\n    # Construct the 2nd order derivative\n    D²ᴰ = (1.0/params.ε^2 * prob.D²ᶻᴰ + 1.0 * ∇ₕ²) # with Dirchilet BC\n    D²ᴺ = (1.0/params.ε^2 * prob.D²ᶻᴺ + 1.0 * ∇ₕ²) # with Neumann BC\n\n    # See `Numerical Implementation' section for the theory\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 1) Now define your 3×3 block-rows in a NamedTuple of 3-tuples\n    # ──────────────────────────────────────────────────────────────────────────────\n    # Construct the matrix `A`\n    Ablocks = (\n        w = (  # w-equation: [z⁴+z²], [∂ᶻ Neumann], [–∇ₕ²]\n                sparse(complex.(-params.E * D⁴ᴰ + 1.0im * params.k * bs.fields.U₀ * D²ᴰ) * params.ε^2),\n                sparse(complex.(prob.Dᶻᴺ)),\n                sparse(complex.(-∇ₕ²))\n        ),\n        ζ = (  # ζ-equation: [∂ᶻU + Dirichlet], [kU–Ek], [zero]\n                sparse(complex.(-bs.fields.∂ᶻU₀ * prob.Dʸ - prob.Dᶻᴰ)),\n                sparse(complex.(1.0im *params.k * bs.fields.U₀ * I⁰ - params.E * D²ᴺ)),\n                spzeros(ComplexF64, s₁, s₂)\n        ),\n        b = (  # b-equation: [∂ᶻB – Dʸᶻᴰ], [k∂ʸB], [–Ek + kU]\n                sparse(complex.(bs.fields.∂ᶻB₀ * I⁰ - bs.fields.∂ʸB₀ * H * prob.Dʸᶻᴰ)),\n                sparse(1.0im * params.k * bs.fields.∂ʸB₀ * H * I⁰),\n                sparse(-params.E * D²ᴺ + 1.0im * params.k * bs.fields.U₀ * I⁰)\n        )\n    )\n\n    # Construct the matrix `A`\n    Bblocks = (\n        w = (  # w-equation mass: [–ε²∂²], zero, zero\n                sparse(-params.ε^2 * D²ᴰ),\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂)\n        ),\n        ζ = (  # ζ-equation mass: zero, [–I], zero\n                spzeros(Float64, s₁, s₂),\n                sparse(-I⁰),\n                spzeros(Float64, s₁, s₂)\n        ),\n        b = (  # b-equation mass: zero, zero, [–I]\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂),\n                sparse(-I⁰)\n        )\n    )\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 2) Assemble the block-row matrices into a GEVPMatrices object\n    # ──────────────────────────────────────────────────────────────────────────────\n    gevp = GEVPMatrices(Ablocks, Bblocks)\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 3) And now you have exactly:\n    #    gevp.A, gevp.B                    → full sparse matrices\n    #    gevp.As.w, gevp.As.ζ, gevp.As.b   → each block-row view of matrix A\n    #    gevp.Bs.w, gevp.Bs.ζ, gevp.Bs.b   → each block-row view of matrix B\n    # ──────────────────────────────────────────────────────────────────────────────\n\n    return gevp.A, gevp.B\nend","category":"page"},{"location":"literated/Stone1971/#Eigenvalue-solver","page":"Stone1971","title":"Eigenvalue solver","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function EigSolver(prob, grid, params, σ₀)\n\n    A, B = generalized_EigValProb(prob, grid, params)\n\n    if params.eig_solver == \"arpack\"\n        λ, Χ = solve_shift_invert_arnoldi(A, B; σ₀=σ₀, which=:LR, sortby=:R)\n\n    elseif params.eig_solver == \"krylov\"\n\n        λ, Χ = solve_shift_invert_krylov(A, B; σ₀=σ₀, which=:LR, sortby=:R)\n\n    elseif params.eig_solver == \"arnoldi\"\n\n        λ, Χ = solve_shift_invert_arnoldi(A, B; σ₀=σ₀, which=:LR, sortby=:R)\n    end\n    # ======================================================================\n    @assert length(λ) > 0 \"No eigenvalue(s) found!\"\n\n    @printf \"largest growth rate : %1.4e%+1.4eim\\n\" real(λ[1]) imag(λ[1])\n\n    return λ[1], Χ[:,1]\nend","category":"page"},{"location":"literated/Stone1971/#Solving-the-problem","page":"Stone1971","title":"Solving the problem","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"function solve_Stone1971(k::Float64)\n\n    # Calling problem parameters\n    params = Params{Float64}()\n\n    # Construct grid and derivative operators\n    grid  = TwoDGrid(params)\n\n    # Construct the necesary operator\n    ops  = OperatorI(params)\n    prob = Problem(grid, ops)\n\n    # update the wavenumber\n    params.k = k\n\n    # initial guess for the growth rate\n    σ₀   = 0.02\n\n    λ, Χ = EigSolver(prob, grid, params, σ₀)\n\n    # Analytical solution of Eady (1949) for the growth rate\n    μ  = 1.0 * params.k * √params.Ri\n    λₜ = 1.0/√params.Ri * √( (coth(0.5μ) - 0.5μ)*(0.5μ - tanh(0.5μ)) )\n\n    @printf \"Analytical solution of Eady (1949) for the growth rate: %f \\n\" λₜ\n\n    return abs(λ.re - λₜ) < 1e-3\n\nend","category":"page"},{"location":"literated/Stone1971/#Result","page":"Stone1971","title":"Result","text":"","category":"section"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"solve_Stone1971(0.1) # growth rate is at k=0.1","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"(attempt  1) trying σ = 0.024000\nConverged: first λ = 0.024868 + i 0.000000 (σ = 0.024000)\n(attempt  2) trying σ = 0.024800\nConverged: first λ = 0.024868 + i -0.000000 (σ = 0.024800)\nSuccessive eigenvalues converged: |Δλ| = 1.94e-12 < 1.00e-05\nlargest growth rate : 2.4868e-02-1.9108e-13im\nAnalytical solution of Eady (1949) for the growth rate: 0.028829 \n","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"","category":"page"},{"location":"literated/Stone1971/","page":"Stone1971","title":"Stone1971","text":"This page was generated using Literate.jl.","category":"page"},{"location":"matrices/#Construction-of-differentiation-matrices","page":"Differentiation matrix","title":"Construction of differentiation matrices","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"This page documents the core spectral‐matrix routines in BiGSTARS.jl.","category":"page"},{"location":"matrices/#Chebyshev-differentiation-matrix","page":"Differentiation matrix","title":"Chebyshev differentiation matrix","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"A standard approach is followed in the construction of the differentiation matrices  \\citep{trefethen2000spectral}. The transformed Gauss–Lobatto points for  z in 0 1 are given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginalign\n    z_j = frac12 cos(jpiN_z) + frac12\n    \n    j = 0 cdots N_z\nendalign","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and the first-order Chebyshev differentiation matrix is given by","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n  (mathrmD_z)_ij = begincases\n     dfrac2N_z^2+13   i=j=0 \n\n    dfracc_ic_j dfrac(-1)^i+jz_i-z_j\n      i neq j\n      c_i\n     begincases \n        2  i=0N_z \n        1  textotherwise\n     endcases\n\n    dfrac-cos(jpiN_z)1-cos^2(jpiN_z)\n     0  i = j  N_z\n\n    -dfrac2N_z^2+13  i=j=N_z\n  endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Chebyshev differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN = 10 # number of grid points\nz, D = cheb(N-1)\n\nnothing # hide","category":"page"},{"location":"matrices/#Fourier-differentiation-matrix","page":"Differentiation matrix","title":"Fourier differentiation matrix","text":"","category":"section"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"For y in 0L_y, the first-order Fourier differentiation matrix for even N_y is,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cotleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"and for odd N_y,","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"beginequation\n    (mathrmD_y)_ij = begincases\n        0  i=j \n\n        dfracpiL_y (-1)^i-j cscleft(dfrac(i-j)h2 right)\n         i neq j\n    endcases\nendequation","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"where h=2piN_y.","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"To construct the Fourier differentiation matrix:","category":"page"},{"location":"matrices/","page":"Differentiation matrix","title":"Differentiation matrix","text":"using BiGSTARS\n\nN    = 10 # number of grid points\nmder = 1  # order of Fourier derivative\ny, D = FourierDiff(N, mder)\n\nThe domain size of `y` is 0 to 2π.\nTo convert into an arbitrary domain [0, L]: \n\ny0 = L/(2π) * y\n𝒟 = (2π/L)^1 * D\n\nFor an n-th derivative:\n\ny, D = FourierDiff(N, n)\n𝒟   = (2π/L)^n * D\n\n\nnothing # hide","category":"page"},{"location":"method/#Shift-and-Invert-Method","page":"Methodology","title":"Shift and Invert Method","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"The shift-and-invert transformation is a common technique for solving the generalized eigenvalue problem","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"A X = lambda B X","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"by focusing on eigenvalues near a target shift sigma:","category":"page"},{"location":"method/","page":"Methodology","title":"Methodology","text":"(A - sigma B)^-1 B X = mu X\nquad mu = (lambda - sigma)^-1","category":"page"},{"location":"method/#Key-Advantages","page":"Methodology","title":"Key Advantages","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Selective targeting: Eigenvalues lambda closest to sigma correspond to the largest magnitudes of mu, enabling efficient extraction via Krylov solvers (e.g., Arnoldi, Lanczos).\nAccelerated convergence: Inverting the shifted operator (A - sigma B) compresses the spectrum so that desired eigenmodes dominate.","category":"page"},{"location":"method/#Algorithm-Outline","page":"Methodology","title":"Algorithm Outline","text":"","category":"section"},{"location":"method/","page":"Methodology","title":"Methodology","text":"Select a shift sigma near the eigenvalue of interest.\nFactor or set up an efficient solver for A - sigma B (e.g., LU, sparse direct, or preconditioned iterative solver).\nIterate with a Krylov-based eigensolver on (A - sigma B)^-1 B to compute mu.\nRecover the original eigenvalue:\nlambda = sigma + mu^-1","category":"page"},{"location":"literated/rRBC/#Finding-critical-Rayleigh-number-for-rotating-Rayleigh-Benard-Convection","page":"rotating RBC","title":"Finding critical Rayleigh number for rotating Rayleigh-Benard Convection","text":"","category":"section"},{"location":"literated/rRBC/#Introduction","page":"rotating RBC","title":"Introduction","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"This code finds critical Rayleigh number for the onset of convection for rotating Rayleigh Benrad Convection (rRBC) where the domain is periodic in y-direction. The code is benchmarked against Chandrashekar's theoretical results. Hydrodynamic and hydromagnetic stability by S. Chandrasekhar, 1961 (page no-95).","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"Parameter:","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"Ekman number E = 10⁴","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"Eigenvalue: critical modified Rayleigh number Ra_c = 1897","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"In this module, we do a linear stability analysis of a 2D rotating Rayleigh-Bernard case where the domain is periodic in the y-direction, in the x-direction is of infinite extent and vertically bounded.","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"The background temperature profile overlinetheta is given by","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"overlinetheta = 1 - z","category":"page"},{"location":"literated/rRBC/#Governing-equations","page":"rotating RBC","title":"Governing equations","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"The non-dimensional form of the equations governing the perturbation is given by","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n    fracEPr fracpartial mathbfupartial t\n    + hatz times mathbfu =\n    -nabla p + Ra theta hatz + E nabla^2 mathbfu\n\n    fracpartial thetapartial t\n    = mathbfu cdot hatz + nabla^2 theta\n\n    nabla cdot mathbfu = 0\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"where E=nu(fH^2) is the Ekman number and Ra = galpha Delta T(f kappa), Delta T is the temperature difference between the bottom and the top walls) is the modified Rayleigh number. By applying the operators (nabla times nabla times) and (nabla times) and taking the z-component of the equations and assuming wave-like perturbations, we obtained the equations for vertical velocity w, vertical vorticity zeta and temperature theta,","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n    E mathcalD^4 w - partial_z zeta = -Ra mathcalD_h^2 theta\n\n    E mathcalD^2 zeta + partial_z w = 0\n\n    mathcalD^2 theta + w = 0\nendalign","category":"page"},{"location":"literated/rRBC/#Normal-mode-solutions","page":"rotating RBC","title":"Normal mode solutions","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"Next we consider normal-mode perturbation solutions in the form of (we seek stationary solutions at the marginal state, i.e., sigma = 0),","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n w zeta theta(xyzt) = mathfrakRbig(tildew tildezeta tildetheta(y z)  e^i kx + sigma tbig)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"where the symbol mathfrakR denotes the real part and a variable with `tilde' denotes an eigenfunction. Finally following systems of differential equations are obtained,","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n    E mathcalD^4  tildew - partial_z tildezeta = - Ra mathcalD_h^2 tildetheta\n\n    E mathcalD^2 tildezeta + partial_z tildew = 0\n\n    mathcalD^2 tildetheta + tildew = 0\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"where","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\nmathcalD^4  = (mathcalD^2 )^2 = big(partial_y^2 + partial_z^2 - k^2big)^2\n textand  mathcalD_h^2 = (partial_y^2 - k^2)\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"The eigenfunctions tildeu, tildev are related to tildew, tildezeta by the relations","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n    -mathcalD_h^2 tildeu = i k partial_z tildew + partial_y tildezeta\n\n    -mathcalD_h^2 tildev = partial_yz tildew -  i k tildezeta\nendalign","category":"page"},{"location":"literated/rRBC/#Boundary-conditions","page":"rotating RBC","title":"Boundary conditions","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"We choose periodic boundary conditions in the y-direction and free-slip, rigid lid, with zero buoyancy flux in the z direction, i.e.,","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n    tildew = partial_zz tildew =\n    partial_z tildezeta = tildetheta = 0\n     textat  z=0 1\nendalign","category":"page"},{"location":"literated/rRBC/#Generalized-eigenvalue-problem-(GEVP)","page":"rotating RBC","title":"Generalized eigenvalue problem (GEVP)","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"The above sets of equations with the boundary conditions can be expressed as a standard generalized eigenvalue problem,","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n AX = λBX\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"where lambda=Ra is the eigenvalue, and X=tildew  tildezeta  tildetheta^T is the eigenvector. The matrices A and B are given by","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n    A = beginbmatrix\n        E mathcalD^4  -partial_z  0 \n        partial_z  E mathcalD^2  0 \n        1  0  mathcalD^2\n    endbmatrix\n\n    B = beginbmatrix\n        0  0  -mathcalD_h^2 \n        0  0  0 \n        0  0  0\n    endbmatrix\nendalign","category":"page"},{"location":"literated/rRBC/#Numerical-Implementation","page":"rotating RBC","title":"Numerical Implementation","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"To implement the above GEVP in a numerical code, we need to actually code following sets of equations:","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\n    A = beginbmatrix\n        E D^4D  -D_z^D  0_n \n        mathcalD^zD  E D^2N  0_n \n        I_n  0_n  mathcalD^2D\n    endbmatrix\n\n    B = beginbmatrix\n        0_n  0_n  -D^2D \n        0_n  0_n  0_n \n        0_n  0_n  0_n\n    endbmatrix\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"where I_n is the identity matrix of size (n times n), where n=N_y N_z, N_y and N_z are the number of grid points in the y and z directions respectively. 0_n is the zero matrix of size (n times n). The differential operator matrices are given by","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"beginalign\nD^2D = mathcalD_y^2 otimes I_z + I_y otimes mathcalD_z^2D - k^2 I_n\n\nD^2N = mathcalD_y^2 otimes I_z + I_y otimes mathcalD_z^2N - k^2 I_n\n\n D^4D = mathcalD_y^4 otimes I_z\n   + I_y otimes mathcalD_z^4D + k^4 I_n - 2 k^2 D_y^2 otimes I_z\n   - 2 k^2 I_y otimes D_z^2D + 2 D_y^2 otimes D_z^2D\nendalign","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"where otimes is the Kronecker product. I_y and I_z are identity matrices of size (N_y times N_y) and (N_z times N_z) respectively, and I=I_y otimes I_z. The superscripts D and N in the operator matrices denote the type of boundary conditions applied (D for Dirichlet or N for Neumann). mathcalD_y, mathcalD_y^2 and mathcalD_y^3 are the first, second and third order Fourier differentiation matrix of size of (N_y times N_y). mathcalD_z, mathcalD_z^2 and mathcalD_z^4 are the first, second and fourth order Chebyshev differentiation matrix of size of (N_z times N_z).","category":"page"},{"location":"literated/rRBC/#Load-required-packages","page":"rotating RBC","title":"Load required packages","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"using LazyGrids\nusing LinearAlgebra\nusing Printf\nusing StaticArrays\nusing SparseArrays\nusing SparseMatrixDicts\nusing FillArrays\nusing SpecialFunctions\nusing Parameters\nusing Test\nusing BenchmarkTools\nusing JLD2\nusing Parameters: @with_kw\n\nusing BiGSTARS\nusing BiGSTARS: AbstractParams\nusing BiGSTARS: Problem, OperatorI, TwoDGrid","category":"page"},{"location":"literated/rRBC/#Parameters","page":"rotating RBC","title":"Parameters","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"@with_kw mutable struct Params{T} <: AbstractParams\n    L::T                = 2π            # horizontal domain size\n    H::T                = 1.0           # vertical   domain size\n    E::T                = 1.0e-4        # the Ekman number\n    Pr::T               = 1.0           # the Prandtl number\n    k::T                = 0.0           # x-wavenumber\n    Ny::Int64           = 120           # no. of y-grid points\n    Nz::Int64           = 30            # no. of Chebyshev points\n    w_bc::String        = \"rigid_lid\"   # boundary condition for vertical velocity\n    ζ_bc::String        = \"free_slip\"   # boundary condition for vertical vorticity\n    b_bc::String        = \"fixed\"       # boundary condition for temperature\n    eig_solver::String  = \"arnoldi\"     # eigenvalue solver\nend","category":"page"},{"location":"literated/rRBC/#Basic-state","page":"rotating RBC","title":"Basic state","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"function basic_state(grid, params)\n\n    Y, Z = ndgrid(grid.y, grid.z)\n    Y    = transpose(Y)\n    Z    = transpose(Z)\n\n    # Define the basic state\n    B₀   = @. 1.0 - Z          # basic state temperature\n    U₀   = @. 0.0 * Z          # basic state along-front velocity\n\n    # Calculate all the necessary derivatives\n    deriv = compute_derivatives(U₀, B₀, grid.y, grid.Dᶻ, grid.D²ᶻ, :All)\n\n    bs = initialize_basic_state_from_fields(B₀, U₀)\n\n    initialize_basic_state!(\n            bs,\n            deriv.∂ʸB₀,  deriv.∂ᶻB₀,\n            deriv.∂ʸU₀,  deriv.∂ᶻU₀,\n            deriv.∂ʸʸU₀, deriv.∂ᶻᶻU₀, deriv.∂ʸᶻU₀,\n            deriv.∂ʸʸB₀, deriv.∂ᶻᶻB₀, deriv.∂ʸᶻB₀\n        )\n\n    return bs\nend","category":"page"},{"location":"literated/rRBC/#Constructing-GEVP","page":"rotating RBC","title":"Constructing GEVP","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"function generalized_EigValProb(prob, grid, params)\n\n    bs = basic_state(grid, params)\n\n    n  = params.Ny * params.Nz\n    I⁰ = sparse(Matrix(1.0I, n, n)) # Identity matrix\n    s₁ = size(I⁰, 1);\n    s₂ = size(I⁰, 2);\n\n    # the horizontal Laplacian operator: ∇ₕ² = ∂ʸʸ - k²\n    ∇ₕ² = SparseMatrixCSC(Zeros(n, n))\n    ∇ₕ² = (1.0 * prob.D²ʸ - 1.0 * params.k^2 * I⁰)\n\n    # Construct the 4th order derivative\n    D⁴ᴰ = (1.0 * prob.D⁴ʸ\n        + 1.0 * prob.D⁴ᶻᴰ\n        + 1.0 * params.k^4 * I⁰\n        - 2.0 * params.k^2 * prob.D²ʸ\n        - 2.0 * params.k^2 * prob.D²ᶻᴰ\n        + 2.0 * prob.D²ʸ²ᶻᴰ)\n\n    # Construct the 2nd order derivative\n    D²ᴰ = (1.0 * prob.D²ᶻᴰ  + 1.0 * ∇ₕ²)  # with Dirchilet BC\n    D²ᴺ = (1.0 * prob.D²ᶻᴺ  + 1.0 * ∇ₕ²)  # with Neumann BC\n\n    # See `Numerical Implementation' section for the theory\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 1) Now define your 3×3 block-rows in a NamedTuple of 3-tuples\n    # ──────────────────────────────────────────────────────────────────────────────\n    # Construct the matrix `A`\n    Ablocks = (\n        w = (  # w-equation: ED⁴ -Dᶻ zero\n                sparse(params.E * D⁴ᴰ),\n                sparse(-prob.Dᶻᴺ),\n                spzeros(Float64, s₁, s₂)\n        ),\n        ζ = (  # ζ-equation: Dᶻ ED² zero\n                sparse(prob.Dᶻᴰ),\n                sparse(params.E * D²ᴺ),\n                spzeros(Float64, s₁, s₂)\n        ),\n        θ = (  # b-equation: I zero D²\n                sparse(I⁰),\n                spzeros(Float64, s₁, s₂),\n                sparse(D²ᴰ)\n        )\n    )\n\n    # Construct the matrix `B`\n    Bblocks = (\n        w = (  # w-equation: zero, zero -∇ₕ²\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂),\n                sparse(-∇ₕ²)\n        ),\n        ζ = (  # ζ-equation: zero, zero, zero\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂)\n        ),\n        θ = (  # b-equation: zero, zero, zero\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂),\n                spzeros(Float64, s₁, s₂)\n        )\n    )\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 2) Assemble the block-row matrices into a GEVPMatrices object\n    # ──────────────────────────────────────────────────────────────────────────────\n    gevp = GEVPMatrices(Ablocks, Bblocks)\n\n\n    # ──────────────────────────────────────────────────────────────────────────────\n    # 3) And now you have exactly:\n    #    gevp.A, gevp.B                    → full sparse matrices\n    #    gevp.As.w, gevp.As.ζ, gevp.As.θ   → each block-row view\n    #    gevp.Bs.w, gevp.Bs.ζ, gevp.Bs.θ\n    # ──────────────────────────────────────────────────────────────────────────────\n\n    return gevp.A, gevp.B\nend","category":"page"},{"location":"literated/rRBC/#Eigenvalue-solver","page":"rotating RBC","title":"Eigenvalue solver","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"function EigSolver(prob, grid, params, σ₀)\n\n    A, B = generalized_EigValProb(prob, grid, params)\n\n    if params.eig_solver == \"arpack\"\n\n        λ, Χ = solve_shift_invert_arpack(A, B;\n                                        σ₀=σ₀,\n                                        which=:LM,\n                                        sortby=:R,\n                                        nev = 10,\n                                        maxiter=100)\n\n    elseif params.eig_solver == \"krylov\"\n\n        λ, Χ = solve_shift_invert_krylov(A, B;\n                                        σ₀=σ₀,\n                                        which=:LM,\n                                        sortby=:R,\n                                        maxiter=100)\n\n    elseif params.eig_solver == \"arnoldi\"\n\n        λ, Χ = solve_shift_invert_arnoldi(A, B;\n                                        σ₀=σ₀,\n                                        which=:LM,\n                                        sortby=:R,\n                                        nev = 10,\n                                        maxiter=100)\n    end\n    # ======================================================================\n    @assert length(λ) > 0 \"No eigenvalue(s) found!\"\n\n    # looking for min Ra\n    λ, Χ = remove_evals(λ, Χ, 10.0, 1.0e15, \"R\")\n    λ, Χ = sort_evals_(λ, Χ,  :R, rev=false)\n\n    print_evals(complex.(λ))\n\n    return λ[1], Χ[:,1]\nend","category":"page"},{"location":"literated/rRBC/#Solving-the-problem","page":"rotating RBC","title":"Solving the problem","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"function solve_rRBC(k::Float64)\n\n    # Calling problem parameters\n    params = Params{Float64}()\n\n    # Construct grid and derivative operators\n    grid  = TwoDGrid(params)\n\n    # Construct the necesary operator\n    ops  = OperatorI(params)\n    prob = Problem(grid, ops)\n\n    # update the wavenumber\n    #params = Params(p; k = k)\n    params.k = k\n\n    # initial guess for the growth rate\n    σ₀   = 0.0\n\n    λ, Χ = EigSolver(prob, grid, params, σ₀)\n\n    # Theoretical results from Chandrashekar (1961)\n    λₜ = 189.7\n    @printf \"Analytical solution of critical Ra: %1.4e \\n\" λₜ\n\n    return abs(real(λ) - λₜ)/λₜ < 1e-4\nend","category":"page"},{"location":"literated/rRBC/#Result","page":"rotating RBC","title":"Result","text":"","category":"section"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"solve_rRBC(0.0) # Critical Rayleigh number is at k=0.0","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"(attempt  1) trying σ = 0.000000\nConverged: first λ = 193.728586 + i 0.000000 (σ = 0.000000)\n(attempt  2) trying σ = 0.000000\nConverged: first λ = 193.728586 + i 0.000000 (σ = 0.000000)\nSuccessive eigenvalues converged: |Δλ| = 7.49e-09 < 1.00e-05\nTop 9 eigenvalues (sorted):\nIdx │ Real Part     Imag Part\n────┼──────────────────────────────\n  9 │  1.937286e+02          \n  8 │  1.933564e+02          \n  7 │  1.933564e+02          \n  6 │  1.907175e+02          \n  5 │  1.907175e+02          \n  4 │  1.906031e+02          \n  3 │  1.906031e+02          \n  2 │  1.897041e+02          \n  1 │  1.897041e+02          \nAnalytical solution of critical Ra: 1.8970e+02 \n","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"","category":"page"},{"location":"literated/rRBC/","page":"rotating RBC","title":"rotating RBC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#BiGSTARS.jl-Documentation","page":"Home","title":"BiGSTARS.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BiGSTARS.jl — a Julia toolkit for bi-global linear-stability analysis of geophysical flows, built on a Chebyshev–Fourier spectral-collocation method.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The examples illustrate the key features of every module.   Browse the collection to see BiGSTARS.jl in action!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stone1971 example\nrRBC example","category":"page"}]
}
